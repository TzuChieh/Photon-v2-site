\doxysection{ph\+::TSPSCExecutor\texorpdfstring{$<$}{<} Work \texorpdfstring{$>$}{>} Class Template Reference}
\hypertarget{classph_1_1_t_s_p_s_c_executor}{}\label{classph_1_1_t_s_p_s_c_executor}\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}


A single-\/producer, single-\/consumer worker thread. Ctor and dtor are not thread safe. Most of the methods are either producer thread only, or thread-\/safe. {\ttfamily \doxylink{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e}{start()}} must be called before adding work since it also serves as a mean to determine the producer thread. Setters for function callbacks can only be called before {\ttfamily \doxylink{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e}{start()}}. Note that if work processor is not set from ctor, {\ttfamily \doxylink{classph_1_1_t_s_p_s_c_executor_aff408fe833f82bb136083d0e62ff8592}{set\+Work\+Processor()}} must be called with a valid processor function.  




{\ttfamily \#include $<$TSPSCExecutor.\+h$>$}

\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a9f6b5ce0addb84a3de6294984c9612a3}{TSPSCExecutor}} ()
\begin{DoxyCompactList}\small\item\em Create an executor waiting for new work. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a6dfdf73fc1054ad47c06b9370768b58f}{TSPSCExecutor}} (std\+::function$<$ void(const Work \&work)$>$ work\+Processor)
\begin{DoxyCompactList}\small\item\em Create an executor waiting for new work. \end{DoxyCompactList}\item 
\mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a98a11651bfe5596cb1acb4d5125c45fb}{\texorpdfstring{$\sim$}{\string~}\+TSPSCExecutor}} ()
\begin{DoxyCompactList}\small\item\em Terminate the execution. Wait for any ongoing work to finish. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e}{start}} ()
\begin{DoxyCompactList}\small\item\em Start the execution of the consumer (worker thread). Whichever thread calls this method will be the producer thread. Can only be called once in the lifetime of the executor. \end{DoxyCompactList}\item 
{\footnotesize template$<$typename Deduced\+Work $>$ }\\void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a348023aebd44b96af2d54e6aacda79a0}{add\+Work}} (Deduced\+Work \&\&work)
\item 
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a75b1bd75567ccb5adcd30bdd592b42ce}{wait\+All\+Works}} ()
\begin{DoxyCompactList}\small\item\em Wait for all queued works to finish. Memory effects on consumer thread are made visible to the producer thread. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a52bee5c6bbc09397af7f73ef55969c93}{request\+Termination}} ()
\begin{DoxyCompactList}\small\item\em Stop the executor. Executor will stop processing any work as soon as possible. Any work that is already being processed will still complete. No further write operations should be performed after requesting termination. Requesting termination multiple times has the same effect. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_ace6ac9244a6753e4a2da159fabd10d8d}{wait\+For\+Termination}} ()
\begin{DoxyCompactList}\small\item\em Wait for the executor to stop. All operations on the consumer thread will be done after this call returns. Memory effects on consumer thread are made visible to the producer thread. Cannot be called on consumer thread as this can lead to deadlock. \end{DoxyCompactList}\item 
std\+::thread\+::id \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a7dd7b547217281c83d117359584375b1}{get\+Id}} () const
\begin{DoxyCompactList}\small\item\em Get ID of the underlying thread. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_ac550b3718b38d56f5684e1ea546ee7d2}{has\+Started}} () const
\begin{DoxyCompactList}\small\item\em Whether the executor has started processing works. \end{DoxyCompactList}\end{DoxyCompactItemize}
\textbf{ }\par
\begin{DoxyCompactItemize}
\item 
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_aff408fe833f82bb136083d0e62ff8592}{set\+Work\+Processor}} (std\+::function$<$ void(const Work \&work)$>$ work\+Processor)
\begin{DoxyCompactList}\small\item\em Setters for callbacks. Callbacks will execute on consumer thread. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_a3352d75b6451c17a0093f81900597d3f}{set\+On\+Consumer\+Start}} (std\+::function$<$ void(void)$>$ on\+Consumer\+Start)
\item 
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor_ae1ccd9b88d8123367b8a194ee2a0d79d}{set\+On\+Consumer\+Terminate}} (std\+::function$<$ void(void)$>$ on\+Consumer\+Terminate)
\end{DoxyCompactItemize}



\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename Work$>$\newline
class ph\+::\+TSPSCExecutor$<$ Work $>$}
A single-\/producer, single-\/consumer worker thread. Ctor and dtor are not thread safe. Most of the methods are either producer thread only, or thread-\/safe. {\ttfamily \doxylink{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e}{start()}} must be called before adding work since it also serves as a mean to determine the producer thread. Setters for function callbacks can only be called before {\ttfamily \doxylink{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e}{start()}}. Note that if work processor is not set from ctor, {\ttfamily \doxylink{classph_1_1_t_s_p_s_c_executor_aff408fe833f82bb136083d0e62ff8592}{set\+Work\+Processor()}} must be called with a valid processor function. 


\begin{DoxyTemplParams}{Template Parameters}
{\em Work} & Type of the work to be processed. \\
\hline
\end{DoxyTemplParams}


\doxysubsection{Constructor \& Destructor Documentation}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_a9f6b5ce0addb84a3de6294984c9612a3}\label{classph_1_1_t_s_p_s_c_executor_a9f6b5ce0addb84a3de6294984c9612a3} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!TSPSCExecutor@{TSPSCExecutor}}
\index{TSPSCExecutor@{TSPSCExecutor}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{TSPSCExecutor()}{TSPSCExecutor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
\mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::\+TSPSCExecutor (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Create an executor waiting for new work. 

\Hypertarget{classph_1_1_t_s_p_s_c_executor_a6dfdf73fc1054ad47c06b9370768b58f}\label{classph_1_1_t_s_p_s_c_executor_a6dfdf73fc1054ad47c06b9370768b58f} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!TSPSCExecutor@{TSPSCExecutor}}
\index{TSPSCExecutor@{TSPSCExecutor}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{TSPSCExecutor()}{TSPSCExecutor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
\mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::\+TSPSCExecutor (\begin{DoxyParamCaption}\item[{std\+::function$<$ void(const Work \&work)$>$}]{work\+Processor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}



Create an executor waiting for new work. 

\Hypertarget{classph_1_1_t_s_p_s_c_executor_a98a11651bfe5596cb1acb4d5125c45fb}\label{classph_1_1_t_s_p_s_c_executor_a98a11651bfe5596cb1acb4d5125c45fb} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!````~TSPSCExecutor@{\texorpdfstring{$\sim$}{\string~}TSPSCExecutor}}
\index{````~TSPSCExecutor@{\texorpdfstring{$\sim$}{\string~}TSPSCExecutor}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{\texorpdfstring{$\sim$}{\string~}TSPSCExecutor()}{\string~TSPSCExecutor()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
\mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::\texorpdfstring{$\sim$}{\string~}\mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{TSPSCExecutor}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Terminate the execution. Wait for any ongoing work to finish. 



\doxysubsection{Member Function Documentation}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_a348023aebd44b96af2d54e6aacda79a0}\label{classph_1_1_t_s_p_s_c_executor_a348023aebd44b96af2d54e6aacda79a0} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!addWork@{addWork}}
\index{addWork@{addWork}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{addWork()}{addWork()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
template$<$typename Deduced\+Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::add\+Work (\begin{DoxyParamCaption}\item[{Deduced\+Work \&\&}]{work }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Basic aquire-\/release semantics are guaranteed. This ensures that all the effects of work done by the producer thread before it enqueues a work will be visible on the consumer thread after it dequeues that work. \begin{DoxyNote}{Note}
Producer thread only. 
\end{DoxyNote}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_a7dd7b547217281c83d117359584375b1}\label{classph_1_1_t_s_p_s_c_executor_a7dd7b547217281c83d117359584375b1} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!getId@{getId}}
\index{getId@{getId}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{getId()}{getId()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
std\+::thread\+::id \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::get\+Id (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Get ID of the underlying thread. 

\begin{DoxyNote}{Note}
Thread-\/safe. 
\end{DoxyNote}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_ac550b3718b38d56f5684e1ea546ee7d2}\label{classph_1_1_t_s_p_s_c_executor_ac550b3718b38d56f5684e1ea546ee7d2} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!hasStarted@{hasStarted}}
\index{hasStarted@{hasStarted}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{hasStarted()}{hasStarted()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
bool \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::has\+Started (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [inline]}}



Whether the executor has started processing works. 

\begin{DoxyNote}{Note}
Producer and consumer thread only. 
\end{DoxyNote}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_a52bee5c6bbc09397af7f73ef55969c93}\label{classph_1_1_t_s_p_s_c_executor_a52bee5c6bbc09397af7f73ef55969c93} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!requestTermination@{requestTermination}}
\index{requestTermination@{requestTermination}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{requestTermination()}{requestTermination()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::request\+Termination (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Stop the executor. Executor will stop processing any work as soon as possible. Any work that is already being processed will still complete. No further write operations should be performed after requesting termination. Requesting termination multiple times has the same effect. 

\begin{DoxyNote}{Note}
Producer thread only. 
\end{DoxyNote}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_a3352d75b6451c17a0093f81900597d3f}\label{classph_1_1_t_s_p_s_c_executor_a3352d75b6451c17a0093f81900597d3f} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!setOnConsumerStart@{setOnConsumerStart}}
\index{setOnConsumerStart@{setOnConsumerStart}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{setOnConsumerStart()}{setOnConsumerStart()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::set\+On\+Consumer\+Start (\begin{DoxyParamCaption}\item[{std\+::function$<$ void(void)$>$}]{on\+Consumer\+Start }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{classph_1_1_t_s_p_s_c_executor_ae1ccd9b88d8123367b8a194ee2a0d79d}\label{classph_1_1_t_s_p_s_c_executor_ae1ccd9b88d8123367b8a194ee2a0d79d} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!setOnConsumerTerminate@{setOnConsumerTerminate}}
\index{setOnConsumerTerminate@{setOnConsumerTerminate}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{setOnConsumerTerminate()}{setOnConsumerTerminate()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::set\+On\+Consumer\+Terminate (\begin{DoxyParamCaption}\item[{std\+::function$<$ void(void)$>$}]{on\+Consumer\+Terminate }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

\Hypertarget{classph_1_1_t_s_p_s_c_executor_aff408fe833f82bb136083d0e62ff8592}\label{classph_1_1_t_s_p_s_c_executor_aff408fe833f82bb136083d0e62ff8592} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!setWorkProcessor@{setWorkProcessor}}
\index{setWorkProcessor@{setWorkProcessor}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{setWorkProcessor()}{setWorkProcessor()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::set\+Work\+Processor (\begin{DoxyParamCaption}\item[{std\+::function$<$ void(const Work \&work)$>$}]{work\+Processor }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Setters for callbacks. Callbacks will execute on consumer thread. 

\begin{DoxyNote}{Note}
Can only be set before \doxylink{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e}{start()}. 
\end{DoxyNote}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e}\label{classph_1_1_t_s_p_s_c_executor_a0d4416821710b9c3c01b9798376a9f4e} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!start@{start}}
\index{start@{start}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{start()}{start()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::start (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Start the execution of the consumer (worker thread). Whichever thread calls this method will be the producer thread. Can only be called once in the lifetime of the executor. 

\begin{DoxyNote}{Note}
The thread that calls this method is considered the producer thread. 
\end{DoxyNote}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_a75b1bd75567ccb5adcd30bdd592b42ce}\label{classph_1_1_t_s_p_s_c_executor_a75b1bd75567ccb5adcd30bdd592b42ce} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!waitAllWorks@{waitAllWorks}}
\index{waitAllWorks@{waitAllWorks}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{waitAllWorks()}{waitAllWorks()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::wait\+All\+Works (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Wait for all queued works to finish. Memory effects on consumer thread are made visible to the producer thread. 

\begin{DoxyNote}{Note}
Producer thread only. 
\end{DoxyNote}
\Hypertarget{classph_1_1_t_s_p_s_c_executor_ace6ac9244a6753e4a2da159fabd10d8d}\label{classph_1_1_t_s_p_s_c_executor_ace6ac9244a6753e4a2da159fabd10d8d} 
\index{ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}!waitForTermination@{waitForTermination}}
\index{waitForTermination@{waitForTermination}!ph::TSPSCExecutor$<$ Work $>$@{ph::TSPSCExecutor$<$ Work $>$}}
\doxysubsubsection{\texorpdfstring{waitForTermination()}{waitForTermination()}}
{\footnotesize\ttfamily template$<$typename Work $>$ \\
void \mbox{\hyperlink{classph_1_1_t_s_p_s_c_executor}{ph\+::\+TSPSCExecutor}}$<$ Work $>$\+::wait\+For\+Termination (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}



Wait for the executor to stop. All operations on the consumer thread will be done after this call returns. Memory effects on consumer thread are made visible to the producer thread. Cannot be called on consumer thread as this can lead to deadlock. 

\begin{DoxyNote}{Note}
Thread-\/safe. 
\end{DoxyNote}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
Source/\+Utility/\+Concurrent/\mbox{\hyperlink{_t_s_p_s_c_executor_8h}{TSPSCExecutor.\+h}}\item 
Source/\+Utility/\+Concurrent/\mbox{\hyperlink{_t_s_p_s_c_executor_8ipp}{TSPSCExecutor.\+ipp}}\end{DoxyCompactItemize}
