\doxysection{Indexed\+UInt\+Buffer.\+h}
\hypertarget{_indexed_u_int_buffer_8h_source}{}\label{_indexed_u_int_buffer_8h_source}\index{Source/Core/Intersectable/DataStructure/IndexedUIntBuffer.h@{Source/Core/Intersectable/DataStructure/IndexedUIntBuffer.h}}

\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ \textcolor{preprocessor}{\#pragma\ once}}
\DoxyCodeLine{00002\ }
\DoxyCodeLine{00003\ \textcolor{preprocessor}{\#include\ "{}Common/primitive\_type.h"{}}}
\DoxyCodeLine{00004\ \textcolor{preprocessor}{\#include\ "{}Common/assertion.h"{}}}
\DoxyCodeLine{00005\ \textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{math_8h}{Math/math.h}}"{}}}
\DoxyCodeLine{00006\ \textcolor{preprocessor}{\#include\ "{}Utility/utility.h"{}}}
\DoxyCodeLine{00007\ }
\DoxyCodeLine{00008\ \textcolor{preprocessor}{\#include\ <cstddef>}}
\DoxyCodeLine{00009\ \textcolor{preprocessor}{\#include\ <climits>}}
\DoxyCodeLine{00010\ \textcolor{preprocessor}{\#include\ <memory>}}
\DoxyCodeLine{00011\ \textcolor{preprocessor}{\#include\ <concepts>}}
\DoxyCodeLine{00012\ \textcolor{preprocessor}{\#include\ <limits>}}
\DoxyCodeLine{00013\ \textcolor{preprocessor}{\#include\ <stdexcept>}}
\DoxyCodeLine{00014\ \textcolor{preprocessor}{\#include\ <format>}}
\DoxyCodeLine{00015\ \textcolor{preprocessor}{\#include\ <cstring>}}
\DoxyCodeLine{00016\ \textcolor{preprocessor}{\#include\ <algorithm>}}
\DoxyCodeLine{00017\ \textcolor{preprocessor}{\#include\ <type\_traits>}}
\DoxyCodeLine{00018\ }
\DoxyCodeLine{00019\ \textcolor{keyword}{namespace\ }\mbox{\hyperlink{namespaceph}{ph}}}
\DoxyCodeLine{00020\ \{}
\DoxyCodeLine{00021\ }
\DoxyCodeLine{00024\ \textcolor{keyword}{class\ }\mbox{\hyperlink{classph_1_1_indexed_u_int_buffer}{IndexedUIntBuffer}}\ final}
\DoxyCodeLine{00025\ \{}
\DoxyCodeLine{00026\ \ \ \ \ \textcolor{keyword}{static\_assert}(\textcolor{keyword}{sizeof}(std::byte)*\ CHAR\_BIT\ ==\ 8,}
\DoxyCodeLine{00027\ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}The\ buffer\ explicitly\ depends\ on\ the\ fact\ that\ std::byte\ contains\ 8\ bits."{}});}
\DoxyCodeLine{00028\ }
\DoxyCodeLine{00029\ \textcolor{keyword}{public}:}
\DoxyCodeLine{00030\ \ \ \ \ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer}{IndexedUIntBuffer}}();}
\DoxyCodeLine{00031\ }
\DoxyCodeLine{00032\ \ \ \ \ \textcolor{comment}{//\ TODO:\ aligned\ memory\ allocation?}}
\DoxyCodeLine{00033\ }
\DoxyCodeLine{00034\ \ \ \ \ \textcolor{keywordtype}{void}\ declareUIntFormat(std::size\_t\ numBitsPerUInt);}
\DoxyCodeLine{00035\ \ \ \ \ \textcolor{keywordtype}{void}\ declareUIntFormatByMaxValue(uint64\ maxValue);}
\DoxyCodeLine{00036\ }
\DoxyCodeLine{00037\ \ \ \ \ \textcolor{keyword}{template}<std::\textcolor{keywordtype}{int}egral\ IntegerType>}
\DoxyCodeLine{00038\ \ \ \ \ \textcolor{keywordtype}{void}\ declareUIntFormat();}
\DoxyCodeLine{00039\ }
\DoxyCodeLine{00040\ \ \ \ \ \textcolor{keywordtype}{void}\ allocate(std::size\_t\ numUInts);}
\DoxyCodeLine{00041\ }
\DoxyCodeLine{00044\ \ \ \ \ \textcolor{keyword}{template}<std::\textcolor{keywordtype}{int}egral\ IntegerType>}
\DoxyCodeLine{00045\ \ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af3a5a8a0d5b72d4aa85cf04814acf32f}{setUInt}}(std::size\_t\ index,\ IntegerType\ value);}
\DoxyCodeLine{00046\ }
\DoxyCodeLine{00052\ \ \ \ \ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ ValueType>}
\DoxyCodeLine{00053\ \ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_ac42c57a15bb2f281f1a9886b29416899}{setUInts}}(\textcolor{keyword}{const}\ ValueType*\ values,\ std::size\_t\ numValues,\ std::size\_t\ dstBeginValueIndex\ =\ 0);}
\DoxyCodeLine{00054\ }
\DoxyCodeLine{00055\ \ \ \ \ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_ac42c57a15bb2f281f1a9886b29416899}{setUInts}}(\textcolor{keyword}{const}\ std::byte*\ srcBytes,\ std::size\_t\ numBytes,\ std::size\_t\ dstOffset\ =\ 0);}
\DoxyCodeLine{00056\ }
\DoxyCodeLine{00057\ \ \ \ \ \textcolor{comment}{//\ TODO:\ templatize}}
\DoxyCodeLine{00058\ \ \ \ \ uint64\ getUInt(std::size\_t\ index)\ \textcolor{keyword}{const};}
\DoxyCodeLine{00059\ }
\DoxyCodeLine{00060\ \ \ \ \ std::size\_t\ numUInts()\ \textcolor{keyword}{const};}
\DoxyCodeLine{00061\ \ \ \ \ std::size\_t\ memoryUsage()\ \textcolor{keyword}{const};}
\DoxyCodeLine{00062\ \ \ \ \ \textcolor{keywordtype}{bool}\ isAllocated()\ \textcolor{keyword}{const};}
\DoxyCodeLine{00063\ }
\DoxyCodeLine{00067\ \ \ \ \ uint64\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_ad9911b2c5e8022c1207cd7d52f3f79d5}{getMaxAllowedValue}}()\ \textcolor{keyword}{const};}
\DoxyCodeLine{00068\ }
\DoxyCodeLine{00072\ \ \ \ \ std::byte*\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af1a4c220a550c453a6ad70f0301dc073}{getData}}();}
\DoxyCodeLine{00073\ \ \ \ \ \textcolor{keyword}{const}\ std::byte*\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af1a4c220a550c453a6ad70f0301dc073}{getData}}()\ \textcolor{keyword}{const};}
\DoxyCodeLine{00075\ }
\DoxyCodeLine{00076\ \textcolor{keyword}{private}:}
\DoxyCodeLine{00077\ \ \ \ \ \textcolor{keyword}{static}\ uint64\ maxAllowedValue(uint8\ numBitsPerUInt);}
\DoxyCodeLine{00078\ }
\DoxyCodeLine{00079\ \ \ \ \ std::unique\_ptr<std::byte[]>\ m\_byteBuffer;}
\DoxyCodeLine{00080\ \ \ \ \ std::size\_t\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_byteBufferSize;}
\DoxyCodeLine{00081\ \ \ \ \ uint8\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ m\_numBitsPerUInt;}
\DoxyCodeLine{00082\ \};}
\DoxyCodeLine{00083\ }
\DoxyCodeLine{00084\ \textcolor{comment}{//\ In-\/header\ Implementations:}}
\DoxyCodeLine{00085\ }
\DoxyCodeLine{00086\ \textcolor{keyword}{template}<std::\textcolor{keywordtype}{int}egral\ IntegerType>}
\DoxyCodeLine{00087\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ IndexedUIntBuffer::declareUIntFormat()}
\DoxyCodeLine{00088\ \{}
\DoxyCodeLine{00089\ \ \ \ \ declareUIntFormat(sizeof\_in\_bits<IntegerType>());}
\DoxyCodeLine{00090\ \}}
\DoxyCodeLine{00091\ }
\DoxyCodeLine{00092\ \textcolor{keyword}{inline}\ std::size\_t\ IndexedUIntBuffer::memoryUsage()\textcolor{keyword}{\ const}}
\DoxyCodeLine{00093\ \textcolor{keyword}{}\{}
\DoxyCodeLine{00094\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{sizeof}(*this)\ +\ m\_byteBufferSize;}
\DoxyCodeLine{00095\ \}}
\DoxyCodeLine{00096\ }
\DoxyCodeLine{00097\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{bool}\ IndexedUIntBuffer::isAllocated()\textcolor{keyword}{\ const}}
\DoxyCodeLine{00098\ \textcolor{keyword}{}\{}
\DoxyCodeLine{00099\ \ \ \ \ \textcolor{keywordflow}{return}\ m\_byteBuffer\ !=\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00100\ \}}
\DoxyCodeLine{00101\ }
\DoxyCodeLine{00102\ \textcolor{keyword}{inline}\ uint64\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_ad9911b2c5e8022c1207cd7d52f3f79d5}{IndexedUIntBuffer::getMaxAllowedValue}}()\textcolor{keyword}{\ const}}
\DoxyCodeLine{00103\ \textcolor{keyword}{}\{}
\DoxyCodeLine{00104\ \ \ \ \ \textcolor{keywordflow}{return}\ maxAllowedValue(m\_numBitsPerUInt);}
\DoxyCodeLine{00105\ \}}
\DoxyCodeLine{00106\ }
\DoxyCodeLine{00107\ \textcolor{keyword}{inline}\ std::size\_t\ IndexedUIntBuffer::numUInts()\textcolor{keyword}{\ const}}
\DoxyCodeLine{00108\ \textcolor{keyword}{}\{}
\DoxyCodeLine{00109\ \ \ \ \ \textcolor{keywordflow}{return}\ m\_numBitsPerUInt\ >\ 0\ ?\ m\_byteBufferSize\ *\ CHAR\_BIT\ /\ m\_numBitsPerUInt\ :\ 0;}
\DoxyCodeLine{00110\ \}}
\DoxyCodeLine{00111\ }
\DoxyCodeLine{00112\ \textcolor{keyword}{inline}\ uint64\ IndexedUIntBuffer::maxAllowedValue(\textcolor{keyword}{const}\ uint8\ numBitsPerUInt)}
\DoxyCodeLine{00113\ \{}
\DoxyCodeLine{00114\ \ \ \ \ \textcolor{keywordflow}{return}\ numBitsPerUInt\ <\ 64}
\DoxyCodeLine{00115\ \ \ \ \ \ \ \ \ ?\ (\textcolor{keyword}{static\_cast<}uint64\textcolor{keyword}{>}(1)\ <<\ numBitsPerUInt)\ -\/\ 1}
\DoxyCodeLine{00116\ \ \ \ \ \ \ \ \ :\ std::numeric\_limits<uint64>::max();}
\DoxyCodeLine{00117\ \}}
\DoxyCodeLine{00118\ }
\DoxyCodeLine{00119\ \textcolor{keyword}{template}<std::\textcolor{keywordtype}{int}egral\ IntegerType>}
\DoxyCodeLine{00120\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af3a5a8a0d5b72d4aa85cf04814acf32f}{IndexedUIntBuffer::setUInt}}(\textcolor{keyword}{const}\ std::size\_t\ index,\ \textcolor{keyword}{const}\ IntegerType\ value)}
\DoxyCodeLine{00121\ \{}
\DoxyCodeLine{00122\ \ \ \ \ PH\_ASSERT(isAllocated());}
\DoxyCodeLine{00123\ }
\DoxyCodeLine{00124\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ uint64Value\ =\ lossless\_integer\_cast<uint64>(value);}
\DoxyCodeLine{00125\ \ \ \ \ \textcolor{keywordflow}{if}(uint64Value\ >\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_ad9911b2c5e8022c1207cd7d52f3f79d5}{getMaxAllowedValue}}())}
\DoxyCodeLine{00126\ \ \ \ \ \{}
\DoxyCodeLine{00127\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{throw}\ std::invalid\_argument(std::format(}
\DoxyCodeLine{00128\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{stringliteral}{"{}Integer\ value\ \{\}\ cannot\ be\ stored\ using\ \{\}\ bits."{}},\ value,\ m\_numBitsPerUInt));}
\DoxyCodeLine{00129\ \ \ \ \ \}}
\DoxyCodeLine{00130\ }
\DoxyCodeLine{00131\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ firstByteIndex\ \ \ \ \ =\ index\ *\ m\_numBitsPerUInt\ /\ CHAR\_BIT;}
\DoxyCodeLine{00132\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ firstByteBitOffset\ =\ index\ *\ m\_numBitsPerUInt\ -\/\ firstByteIndex\ *\ CHAR\_BIT;}
\DoxyCodeLine{00133\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ numStraddledBytes\ \ =\ (firstByteBitOffset\ +\ m\_numBitsPerUInt\ +\ (CHAR\_BIT\ -\/\ 1))\ /\ CHAR\_BIT;}
\DoxyCodeLine{00134\ }
\DoxyCodeLine{00135\ \ \ \ \ PH\_ASSERT\_LT(firstByteBitOffset,\ CHAR\_BIT);}
\DoxyCodeLine{00136\ \ \ \ \ PH\_ASSERT\_LE(numStraddledBytes,\ 8\ +\ 1);}
\DoxyCodeLine{00137\ \ \ \ \ PH\_ASSERT\_LE(firstByteIndex\ +\ numStraddledBytes,\ m\_byteBufferSize);}
\DoxyCodeLine{00138\ }
\DoxyCodeLine{00139\ \ \ \ \ \textcolor{comment}{//\ Potentially\ read\ straddled\ previous\ \&\ next\ values'\ bits}}
\DoxyCodeLine{00140\ \ \ \ \ uint64\ rawBits\ =\ 0;}
\DoxyCodeLine{00141\ \ \ \ \ std::memcpy(\&rawBits,\ \&m\_byteBuffer[firstByteIndex],\ std::min<std::size\_t>(numStraddledBytes,\ 8));}
\DoxyCodeLine{00142\ }
\DoxyCodeLine{00143\ \ \ \ \ \textcolor{comment}{//\ Store\ value\ between\ the\ back\ of\ previous\ value\ and\ the\ head\ of\ next\ value}}
\DoxyCodeLine{00144\ \ \ \ \ rawBits\ =\ \mbox{\hyperlink{namespaceph_1_1math_af11f191a13f32e5ff37ba539bb731029}{math::clear\_bits\_in\_range}}(rawBits,\ firstByteBitOffset,\ firstByteBitOffset\ +\ m\_numBitsPerUInt);}
\DoxyCodeLine{00145\ \ \ \ \ rawBits\ |=\ (uint64Value\ <<\ firstByteBitOffset);}
\DoxyCodeLine{00146\ \ \ \ \ std::memcpy(\&m\_byteBuffer[firstByteIndex],\ \&rawBits,\ std::min<std::size\_t>(numStraddledBytes,\ 8));}
\DoxyCodeLine{00147\ }
\DoxyCodeLine{00148\ \ \ \ \ \textcolor{comment}{//\ Handle\ situations\ where\ the\ value\ needs\ the\ 9-\/th\ byte\ (straddles\ next\ byte),\ this\ can\ happen}}
\DoxyCodeLine{00149\ \ \ \ \ \textcolor{comment}{//\ since\ we\ support\ any\ number\ of\ bits\ per\ index}}
\DoxyCodeLine{00150\ \ \ \ \ \textcolor{keywordflow}{if}(numStraddledBytes\ >\ 8)}
\DoxyCodeLine{00151\ \ \ \ \ \{}
\DoxyCodeLine{00152\ \ \ \ \ \ \ \ \ uint8\ remainingRawBits;}
\DoxyCodeLine{00153\ \ \ \ \ \ \ \ \ std::memcpy(\&remainingRawBits,\ \&m\_byteBuffer[firstByteIndex\ +\ 8],\ 1);}
\DoxyCodeLine{00154\ }
\DoxyCodeLine{00155\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Store\ the\ remaining\ value\ before\ next\ value}}
\DoxyCodeLine{00156\ \ \ \ \ \ \ \ \ remainingRawBits\ =\ \mbox{\hyperlink{namespaceph_1_1math_af11f191a13f32e5ff37ba539bb731029}{math::clear\_bits\_in\_range}}(remainingRawBits,\ \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(0),\ firstByteBitOffset\ +\ m\_numBitsPerUInt\ -\/\ 64);}
\DoxyCodeLine{00157\ \ \ \ \ \ \ \ \ remainingRawBits\ |=\ \textcolor{keyword}{static\_cast<}uint8\textcolor{keyword}{>}(uint64Value\ >>\ (64\ -\/\ firstByteBitOffset));}
\DoxyCodeLine{00158\ \ \ \ \ \ \ \ \ std::memcpy(\&m\_byteBuffer[firstByteIndex\ +\ 8],\ \&remainingRawBits,\ 1);}
\DoxyCodeLine{00159\ \ \ \ \ \}}
\DoxyCodeLine{00160\ \}}
\DoxyCodeLine{00161\ }
\DoxyCodeLine{00162\ \textcolor{keyword}{template}<\textcolor{keyword}{typename}\ ValueType>}
\DoxyCodeLine{00163\ \textcolor{keyword}{inline}\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_ac42c57a15bb2f281f1a9886b29416899}{IndexedUIntBuffer::setUInts}}(}
\DoxyCodeLine{00164\ \ \ \ \ \textcolor{keyword}{const}\ ValueType*\ \textcolor{keyword}{const}\ values,}
\DoxyCodeLine{00165\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ \ \ \ \ \ numValues,}
\DoxyCodeLine{00166\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ \ \ \ \ \ dstBeginValueIndex)}
\DoxyCodeLine{00167\ \{}
\DoxyCodeLine{00168\ \ \ \ \ PH\_ASSERT(values);}
\DoxyCodeLine{00169\ }
\DoxyCodeLine{00170\ \ \ \ \ \textcolor{comment}{//\ Directly\ copy\ the\ value\ buffer\ if\ the\ formats\ matched}}
\DoxyCodeLine{00171\ \ \ \ \ \textcolor{keywordflow}{if}(std::is\_unsigned\_v<ValueType>\ \&\&\ sizeof\_in\_bits<ValueType>()\ ==\ m\_numBitsPerUInt)}
\DoxyCodeLine{00172\ \ \ \ \ \{}
\DoxyCodeLine{00173\ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_ac42c57a15bb2f281f1a9886b29416899}{setUInts}}(}
\DoxyCodeLine{00174\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keyword}{reinterpret\_cast<}\textcolor{keyword}{const\ }std::byte*\textcolor{keyword}{>}(values),\ }
\DoxyCodeLine{00175\ \ \ \ \ \ \ \ \ \ \ \ \ numValues\ *\ \textcolor{keyword}{sizeof}(ValueType),\ }
\DoxyCodeLine{00176\ \ \ \ \ \ \ \ \ \ \ \ \ dstBeginValueIndex\ *\ \textcolor{keyword}{sizeof}(ValueType));}
\DoxyCodeLine{00177\ \ \ \ \ \}}
\DoxyCodeLine{00178\ \ \ \ \ \textcolor{comment}{//\ Resort\ to\ copy\ one\ by\ one}}
\DoxyCodeLine{00179\ \ \ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00180\ \ \ \ \ \{}
\DoxyCodeLine{00181\ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{for}(std::size\_t\ uintIdx\ =\ dstBeginValueIndex,\ valueIdx\ =\ 0;\ valueIdx\ <\ numValues;\ ++uintIdx,\ ++valueIdx)}
\DoxyCodeLine{00182\ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00183\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{if}\ \textcolor{keyword}{constexpr}(std::is\_integral\_v<ValueType>)}
\DoxyCodeLine{00184\ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00185\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af3a5a8a0d5b72d4aa85cf04814acf32f}{setUInt}}(uintIdx,\ values[valueIdx]);}
\DoxyCodeLine{00186\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00187\ \ \ \ \ \ \ \ \ \ \ \ \ \textcolor{keywordflow}{else}}
\DoxyCodeLine{00188\ \ \ \ \ \ \ \ \ \ \ \ \ \{}
\DoxyCodeLine{00189\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af3a5a8a0d5b72d4aa85cf04814acf32f}{setUInt}}(uintIdx,\ \textcolor{keyword}{static\_cast<}uint64\textcolor{keyword}{>}(values[valueIdx]));}
\DoxyCodeLine{00190\ \ \ \ \ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00191\ \ \ \ \ \ \ \ \ \}}
\DoxyCodeLine{00192\ \ \ \ \ \}}
\DoxyCodeLine{00193\ \}}
\DoxyCodeLine{00194\ }
\DoxyCodeLine{00195\ \textcolor{keyword}{inline}\ uint64\ IndexedUIntBuffer::getUInt(\textcolor{keyword}{const}\ std::size\_t\ index)\textcolor{keyword}{\ const}}
\DoxyCodeLine{00196\ \textcolor{keyword}{}\{}
\DoxyCodeLine{00197\ \ \ \ \ PH\_ASSERT(isAllocated());}
\DoxyCodeLine{00198\ }
\DoxyCodeLine{00199\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ firstByteIndex\ \ \ \ \ =\ index\ *\ m\_numBitsPerUInt\ /\ CHAR\_BIT;}
\DoxyCodeLine{00200\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ firstByteBitOffset\ =\ index\ *\ m\_numBitsPerUInt\ -\/\ firstByteIndex\ *\ CHAR\_BIT;}
\DoxyCodeLine{00201\ \ \ \ \ \textcolor{keyword}{const}\ std::size\_t\ numStraddledBytes\ \ =\ (firstByteBitOffset\ +\ m\_numBitsPerUInt\ +\ (CHAR\_BIT\ -\/\ 1))\ /\ CHAR\_BIT;}
\DoxyCodeLine{00202\ }
\DoxyCodeLine{00203\ \ \ \ \ PH\_ASSERT\_LT(firstByteBitOffset,\ CHAR\_BIT);}
\DoxyCodeLine{00204\ \ \ \ \ PH\_ASSERT\_LE(numStraddledBytes,\ 8\ +\ 1);}
\DoxyCodeLine{00205\ \ \ \ \ PH\_ASSERT\_LE(firstByteIndex\ +\ numStraddledBytes,\ m\_byteBufferSize);}
\DoxyCodeLine{00206\ }
\DoxyCodeLine{00207\ \ \ \ \ \textcolor{comment}{//\ Read\ current\ value's\ bits\ (first\ 8\ bytes,\ at\ most)}}
\DoxyCodeLine{00208\ \ \ \ \ uint64\ rawBits\ =\ 0;}
\DoxyCodeLine{00209\ \ \ \ \ std::memcpy(\&rawBits,\ \&m\_byteBuffer[firstByteIndex],\ std::min<std::size\_t>(numStraddledBytes,\ 8));}
\DoxyCodeLine{00210\ }
\DoxyCodeLine{00211\ \ \ \ \ \textcolor{comment}{//\ Clear\ previous\ and\ next\ values'\ bits\ if\ any,\ then\ get\ the\ value}}
\DoxyCodeLine{00212\ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ bitMask\ =\ math::set\_bits\_in\_range<uint64>(0,\ firstByteBitOffset,\ firstByteBitOffset\ +\ m\_numBitsPerUInt);}
\DoxyCodeLine{00213\ \ \ \ \ uint64\ value\ =\ (rawBits\ \&\ bitMask)\ >>\ firstByteBitOffset;}
\DoxyCodeLine{00214\ }
\DoxyCodeLine{00215\ \ \ \ \ \textcolor{comment}{//\ Handle\ situations\ where\ the\ value\ needs\ the\ 9-\/th\ byte\ (straddles\ next\ byte),\ this\ can\ happen}}
\DoxyCodeLine{00216\ \ \ \ \ \textcolor{comment}{//\ since\ we\ support\ any\ number\ of\ bits\ per\ index}}
\DoxyCodeLine{00217\ \ \ \ \ \textcolor{keywordflow}{if}(numStraddledBytes\ >\ 8)}
\DoxyCodeLine{00218\ \ \ \ \ \{}
\DoxyCodeLine{00219\ \ \ \ \ \ \ \ \ uint8\ remainingRawBits;}
\DoxyCodeLine{00220\ \ \ \ \ \ \ \ \ std::memcpy(\&remainingRawBits,\ \&m\_byteBuffer[firstByteIndex\ +\ 8],\ 1);}
\DoxyCodeLine{00221\ }
\DoxyCodeLine{00222\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Extract\ the\ remaining\ value\ and\ clear\ next\ value's\ bits\ if\ any}}
\DoxyCodeLine{00223\ \ \ \ \ \ \ \ \ \textcolor{keyword}{const}\ \textcolor{keyword}{auto}\ remainingBitsBitMask\ =\ math::set\_bits\_in\_range<uint8>(0,\ \textcolor{keyword}{static\_cast<}std::size\_t\textcolor{keyword}{>}(0),\ firstByteBitOffset\ +\ m\_numBitsPerUInt\ -\/\ 64);}
\DoxyCodeLine{00224\ \ \ \ \ \ \ \ \ remainingRawBits\ \&=\ remainingBitsBitMask;}
\DoxyCodeLine{00225\ }
\DoxyCodeLine{00226\ \ \ \ \ \ \ \ \ \textcolor{comment}{//\ Add\ the\ remaining\ bits\ to\ the\ value}}
\DoxyCodeLine{00227\ \ \ \ \ \ \ \ \ value\ |=\ (\textcolor{keyword}{static\_cast<}uint64\textcolor{keyword}{>}(remainingRawBits)\ <<\ (64\ -\/\ firstByteBitOffset));}
\DoxyCodeLine{00228\ \ \ \ \ \}}
\DoxyCodeLine{00229\ }
\DoxyCodeLine{00230\ \ \ \ \ \textcolor{keywordflow}{return}\ value;}
\DoxyCodeLine{00231\ \}}
\DoxyCodeLine{00232\ }
\DoxyCodeLine{00233\ \textcolor{keyword}{inline}\ std::byte*\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af1a4c220a550c453a6ad70f0301dc073}{IndexedUIntBuffer::getData}}()}
\DoxyCodeLine{00234\ \{}
\DoxyCodeLine{00235\ \ \ \ \ PH\_ASSERT(isAllocated());}
\DoxyCodeLine{00236\ \ \ \ \ \textcolor{keywordflow}{return}\ m\_byteBuffer.get();}
\DoxyCodeLine{00237\ \}}
\DoxyCodeLine{00238\ }
\DoxyCodeLine{00239\ \textcolor{keyword}{inline}\ \textcolor{keyword}{const}\ std::byte*\ \mbox{\hyperlink{classph_1_1_indexed_u_int_buffer_af1a4c220a550c453a6ad70f0301dc073}{IndexedUIntBuffer::getData}}()\textcolor{keyword}{\ const}}
\DoxyCodeLine{00240\ \textcolor{keyword}{}\{}
\DoxyCodeLine{00241\ \ \ \ \ PH\_ASSERT(isAllocated());}
\DoxyCodeLine{00242\ \ \ \ \ \textcolor{keywordflow}{return}\ m\_byteBuffer.get();}
\DoxyCodeLine{00243\ \}}
\DoxyCodeLine{00244\ }
\DoxyCodeLine{00245\ \}\textcolor{comment}{//\ end\ namespace\ ph}}

\end{DoxyCode}
