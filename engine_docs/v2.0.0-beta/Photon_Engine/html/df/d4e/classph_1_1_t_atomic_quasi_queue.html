<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon Engine: ph::TAtomicQuasiQueue&lt; T &gt; Class Template Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Photon Engine<span id="projectnumber">&#160;2.0.0-beta</span>
   </div>
   <div id="projectbrief">A physically based renderer.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('df/d4e/classph_1_1_t_atomic_quasi_queue.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="../../d0/db3/classph_1_1_t_atomic_quasi_queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ph::TAtomicQuasiQueue&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A multi-producer, multi-consumer, lock-free concurrent queue-like structure. For single-thread uses, it is a FIFO queue. For multi-thread uses, it is <em>mostly</em> a FIFO queue. Specifically, items put in by a given producer will all come out in the same order (FIFO). But there is no coordination between items from other producers&ndash;two items put in by two different producers will come out in an undefined order relative to each other (the interleaving between different streams of items from different producers is undefined, even with external synchronization). It is possible some items will starve in the queue if more items are enqueued than dequeued. Guarantees aquire-release semantics for items that are enqueued/dequeued.  
 <a href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="../../d4/d6d/_t_atomic_quasi_queue_8h_source.html">TAtomicQuasiQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a171c295f895f7d145938580f651373be" id="r_a171c295f895f7d145938580f651373be"><td class="memItemLeft" align="right" valign="top"><a id="a171c295f895f7d145938580f651373be" name="a171c295f895f7d145938580f651373be"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TAtomicQuasiQueue</b> (std::size_t initialCapacity)</td></tr>
<tr class="separator:a171c295f895f7d145938580f651373be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef12bfe3e639ef4b72d9d24ec59de22a" id="r_aef12bfe3e639ef4b72d9d24ec59de22a"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:aef12bfe3e639ef4b72d9d24ec59de22a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html#aef12bfe3e639ef4b72d9d24ec59de22a">enqueue</a> (U &amp;&amp;item)</td></tr>
<tr class="memdesc:aef12bfe3e639ef4b72d9d24ec59de22a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an item. Allocate memory if required. Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by a thread before it enqueues an item will be visible on another thread after it dequeues that item. See <a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html#a2cbff98c159d9c613988a792292744a5" title="Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory...">tryDequeue(T*)</a> for how to ensure the item can be dequeued on another thread.  <br /></td></tr>
<tr class="separator:aef12bfe3e639ef4b72d9d24ec59de22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca5b0773748c084d5ace907be044a71" id="r_afca5b0773748c084d5ace907be044a71"><td class="memTemplParams" colspan="2"><a id="afca5b0773748c084d5ace907be044a71" name="afca5b0773748c084d5ace907be044a71"></a>
template&lt;std::input_iterator Iterator&gt; </td></tr>
<tr class="memitem:afca5b0773748c084d5ace907be044a71"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>enqueueBulk</b> (Iterator firstItem, std::size_t numItems)</td></tr>
<tr class="memdesc:afca5b0773748c084d5ace907be044a71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue multiple items at once. Similar to <code>enqueue(1)</code>. Use <code>std::make_move_iterator</code> if the items should be moved instead of copied. <br /></td></tr>
<tr class="separator:afca5b0773748c084d5ace907be044a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae60f1c33f0ab1b97920ab66481d9f2d8" id="r_ae60f1c33f0ab1b97920ab66481d9f2d8"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:ae60f1c33f0ab1b97920ab66481d9f2d8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html#ae60f1c33f0ab1b97920ab66481d9f2d8">tryEnqueue</a> (U &amp;&amp;item)</td></tr>
<tr class="memdesc:ae60f1c33f0ab1b97920ab66481d9f2d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to enqueue an item. Never allocate memory.  <br /></td></tr>
<tr class="separator:ae60f1c33f0ab1b97920ab66481d9f2d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cbff98c159d9c613988a792292744a5" id="r_a2cbff98c159d9c613988a792292744a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html#a2cbff98c159d9c613988a792292744a5">tryDequeue</a> (T *out_item)</td></tr>
<tr class="memdesc:a2cbff98c159d9c613988a792292744a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory effect of enqueue is not visible. Dequeue can also fail spuriously if there is another consumer (under contention). To guarantee all enqueued items eventually got dequeued, memory effects must be made visible to the dequeuing threads.  <br /></td></tr>
<tr class="separator:a2cbff98c159d9c613988a792292744a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d59d081184c662de6ed5ba1440b42ec" id="r_a8d59d081184c662de6ed5ba1440b42ec"><td class="memTemplParams" colspan="2"><a id="a8d59d081184c662de6ed5ba1440b42ec" name="a8d59d081184c662de6ed5ba1440b42ec"></a>
template&lt;std::output_iterator&lt; T &gt; Iterator&gt; </td></tr>
<tr class="memitem:a8d59d081184c662de6ed5ba1440b42ec"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><b>tryDequeueBulk</b> (Iterator out_firstItem, std::size_t numItems)</td></tr>
<tr class="separator:a8d59d081184c662de6ed5ba1440b42ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01fca94d667587ae18b36ca558b1167c" id="r_a01fca94d667587ae18b36ca558b1167c"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html#a01fca94d667587ae18b36ca558b1167c">estimatedSize</a> () const</td></tr>
<tr class="memdesc:a01fca94d667587ae18b36ca558b1167c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximated size of the queue.  <br /></td></tr>
<tr class="separator:a01fca94d667587ae18b36ca558b1167c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class ph::TAtomicQuasiQueue&lt; T &gt;</div><p>A multi-producer, multi-consumer, lock-free concurrent queue-like structure. For single-thread uses, it is a FIFO queue. For multi-thread uses, it is <em>mostly</em> a FIFO queue. Specifically, items put in by a given producer will all come out in the same order (FIFO). But there is no coordination between items from other producers&ndash;two items put in by two different producers will come out in an undefined order relative to each other (the interleaving between different streams of items from different producers is undefined, even with external synchronization). It is possible some items will starve in the queue if more items are enqueued than dequeued. Guarantees aquire-release semantics for items that are enqueued/dequeued. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="aef12bfe3e639ef4b72d9d24ec59de22a" name="aef12bfe3e639ef4b72d9d24ec59de22a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef12bfe3e639ef4b72d9d24ec59de22a">&#9670;&#160;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html">ph::TAtomicQuasiQueue</a>&lt; T &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue an item. Allocate memory if required. Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by a thread before it enqueues an item will be visible on another thread after it dequeues that item. See <a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html#a2cbff98c159d9c613988a792292744a5" title="Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory...">tryDequeue(T*)</a> for how to ensure the item can be dequeued on another thread. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a01fca94d667587ae18b36ca558b1167c" name="a01fca94d667587ae18b36ca558b1167c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01fca94d667587ae18b36ca558b1167c">&#9670;&#160;</a></span>estimatedSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html">ph::TAtomicQuasiQueue</a>&lt; T &gt;::estimatedSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximated size of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of items in the queue. The esimation is only accurate if all memory writes to the queue is guaranteed to be visible. Note that 0 may be returned even if the queue is, in fact, not empty. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a2cbff98c159d9c613988a792292744a5" name="a2cbff98c159d9c613988a792292744a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cbff98c159d9c613988a792292744a5">&#9670;&#160;</a></span>tryDequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html">ph::TAtomicQuasiQueue</a>&lt; T &gt;::tryDequeue </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>out_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory effect of enqueue is not visible. Dequeue can also fail spuriously if there is another consumer (under contention). To guarantee all enqueued items eventually got dequeued, memory effects must be made visible to the dequeuing threads. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an item is dequeued. <code>false</code> otherwise (even if the queue is not empty). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="ae60f1c33f0ab1b97920ab66481d9f2d8" name="ae60f1c33f0ab1b97920ab66481d9f2d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae60f1c33f0ab1b97920ab66481d9f2d8">&#9670;&#160;</a></span>tryEnqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html">ph::TAtomicQuasiQueue</a>&lt; T &gt;::tryEnqueue </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to enqueue an item. Never allocate memory. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the item is enqueued. <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/Utility/Concurrent/<a class="el" href="../../d4/d6d/_t_atomic_quasi_queue_8h_source.html">TAtomicQuasiQueue.h</a></li>
<li>Source/Utility/Concurrent/<a class="el" href="../../d7/d45/_t_atomic_quasi_queue_8ipp_source.html">TAtomicQuasiQueue.ipp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="../../d3/d5c/namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="../../df/d4e/classph_1_1_t_atomic_quasi_queue.html">TAtomicQuasiQueue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
