<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon Editor Library: ph::editor::TFrameWorkerThread&lt; NUM_BUFFERS, R(Args...)&gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<!-- Add a link to project GitHub by https://tholman.com/github-corners/ -->
<a href="https://github.com/TzuChieh/Photon-v2" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Photon Editor Library<span id="projectnumber">&#160;2.0.0-beta</span>
   </div>
   <div id="projectbrief">A physically based renderer.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classph_1_1editor_1_1_t_frame_worker_thread_3_01_n_u_m___b_u_f_f_e_r_s_00_01_r_07_args_8_8_8_08_4.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classph_1_1editor_1_1_t_frame_worker_thread_3_01_n_u_m___b_u_f_f_e_r_s_00_01_r_07_args_8_8_8_08_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ph::editor::TFrameWorkerThread&lt; NUM_BUFFERS, R(Args...)&gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_t_frame_worker_thread_8h_source.html">TFrameWorkerThread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ph::editor::TFrameWorkerThread&lt; NUM_BUFFERS, R(Args...)&gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classph_1_1editor_1_1_t_frame_worker_thread_3_01_n_u_m___b_u_f_f_e_r_s_00_01_r_07_args_8_8_8_08_4.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a977e8183004ac999d670215e3bc90d78" id="r_a977e8183004ac999d670215e3bc90d78"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a977e8183004ac999d670215e3bc90d78">Work</a> = TFunction&lt;<a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;</td></tr>
<tr class="separator:a977e8183004ac999d670215e3bc90d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:abd4665d907aa02a05c9d8ff2d5f4d982" id="r_abd4665d907aa02a05c9d8ff2d5f4d982"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abd4665d907aa02a05c9d8ff2d5f4d982">TFrameWorkerThread</a> ()</td></tr>
<tr class="separator:abd4665d907aa02a05c9d8ff2d5f4d982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed8a66b43938d09af0c53c37b0c15a9" id="r_a0ed8a66b43938d09af0c53c37b0c15a9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ed8a66b43938d09af0c53c37b0c15a9">TFrameWorkerThread</a> (bool shouldFlushBufferBeforeStop)</td></tr>
<tr class="separator:a0ed8a66b43938d09af0c53c37b0c15a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65bfdacf5c15c20f9390dfbd0a89b6a5" id="r_a65bfdacf5c15c20f9390dfbd0a89b6a5"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a65bfdacf5c15c20f9390dfbd0a89b6a5">~TFrameWorkerThread</a> ()</td></tr>
<tr class="separator:a65bfdacf5c15c20f9390dfbd0a89b6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05a317731cb316946ab9afd157d95587" id="r_a05a317731cb316946ab9afd157d95587"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a05a317731cb316946ab9afd157d95587">onAsyncProcessWork</a> (const <a class="el" href="#a977e8183004ac999d670215e3bc90d78">Work</a> &amp;work)=0</td></tr>
<tr class="memdesc:a05a317731cb316946ab9afd157d95587"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when each work is extracted and is going to be processed.  <br /></td></tr>
<tr class="separator:a05a317731cb316946ab9afd157d95587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d62a9f305615a9356f4af8ffc0bc911" id="r_a9d62a9f305615a9356f4af8ffc0bc911"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d62a9f305615a9356f4af8ffc0bc911">onAsyncWorkerStart</a> ()</td></tr>
<tr class="memdesc:a9d62a9f305615a9356f4af8ffc0bc911"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the worker has started.  <br /></td></tr>
<tr class="separator:a9d62a9f305615a9356f4af8ffc0bc911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e00dbbe244c932751963a9b8d55861" id="r_a94e00dbbe244c932751963a9b8d55861"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94e00dbbe244c932751963a9b8d55861">onAsyncWorkerStop</a> ()</td></tr>
<tr class="memdesc:a94e00dbbe244c932751963a9b8d55861"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the worker has stopped.  <br /></td></tr>
<tr class="separator:a94e00dbbe244c932751963a9b8d55861"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c80a273319fd3e84fbbed0c5c1f8ebe" id="r_a5c80a273319fd3e84fbbed0c5c1f8ebe"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c80a273319fd3e84fbbed0c5c1f8ebe">onBeginFrame</a> ()</td></tr>
<tr class="memdesc:a5c80a273319fd3e84fbbed0c5c1f8ebe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called right after the frame begins.  <br /></td></tr>
<tr class="separator:a5c80a273319fd3e84fbbed0c5c1f8ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234f8a4fe9693f7c85d6e8cd197fa8e6" id="r_a234f8a4fe9693f7c85d6e8cd197fa8e6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a234f8a4fe9693f7c85d6e8cd197fa8e6">onEndFrame</a> ()</td></tr>
<tr class="memdesc:a234f8a4fe9693f7c85d6e8cd197fa8e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called right before the frame ends.  <br /></td></tr>
<tr class="separator:a234f8a4fe9693f7c85d6e8cd197fa8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccac1b02007ffec04f9a1ac7a8ea564" id="r_aeccac1b02007ffec04f9a1ac7a8ea564"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccac1b02007ffec04f9a1ac7a8ea564">startWorker</a> ()</td></tr>
<tr class="memdesc:aeccac1b02007ffec04f9a1ac7a8ea564"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the worker. Call to this method synchronizes-with the execution of the worker thread. This method should not be called in the ctor as the worker thread will call virtual methods internally, which leads to possible UB if any derived class has not been initialized yet.  <br /></td></tr>
<tr class="separator:aeccac1b02007ffec04f9a1ac7a8ea564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae01fc47788fe7c65a8300d2d66fd9720" id="r_ae01fc47788fe7c65a8300d2d66fd9720"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame</a> ()</td></tr>
<tr class="separator:ae01fc47788fe7c65a8300d2d66fd9720"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c961f276e1af646dc807d50697f66af" id="r_a2c961f276e1af646dc807d50697f66af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame</a> ()</td></tr>
<tr class="separator:a2c961f276e1af646dc807d50697f66af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab94d36143ba6f4154e1fa10a4c0aed20" id="r_ab94d36143ba6f4154e1fa10a4c0aed20"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:ab94d36143ba6f4154e1fa10a4c0aed20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab94d36143ba6f4154e1fa10a4c0aed20">addWork</a> (Func &amp;&amp;workFunc)</td></tr>
<tr class="separator:ab94d36143ba6f4154e1fa10a4c0aed20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a17998c6c5868dca6c82cc09331424" id="r_ad8a17998c6c5868dca6c82cc09331424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad8a17998c6c5868dca6c82cc09331424">addWork</a> (<a class="el" href="#a977e8183004ac999d670215e3bc90d78">Work</a> work)</td></tr>
<tr class="memdesc:ad8a17998c6c5868dca6c82cc09331424"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a work that will be executed on the worker thread. Can only be called after the frame begins and before the frame ends, i.e., between calls to <code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code> and <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code>. Additionally, calling from frame callbacks such as <code><a class="el" href="#a5c80a273319fd3e84fbbed0c5c1f8ebe" title="Called right after the frame begins.">onBeginFrame()</a></code> and <code><a class="el" href="#a234f8a4fe9693f7c85d6e8cd197fa8e6" title="Called right before the frame ends.">onEndFrame()</a></code> is also allowed.  <br /></td></tr>
<tr class="separator:ad8a17998c6c5868dca6c82cc09331424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90935fc18ecbabdebe864c4b4f272c5" id="r_aa90935fc18ecbabdebe864c4b4f272c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa90935fc18ecbabdebe864c4b4f272c5">requestWorkerStop</a> ()</td></tr>
<tr class="memdesc:aa90935fc18ecbabdebe864c4b4f272c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the worker thread to stop. The worker thread will stop as soon as possible. Currently processing frame will still complete before the worker stop. Whether works in buffered frames will be executed or not depends on the value of <code>shouldFlushBufferedWorksBeforeStop</code> specified to ctor. Can only be called between <code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code> and <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code>. Works can still be added after this call.  <br /></td></tr>
<tr class="separator:aa90935fc18ecbabdebe864c4b4f272c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fc5f3a250fb055afb97c7a102b601a" id="r_a44fc5f3a250fb055afb97c7a102b601a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a44fc5f3a250fb055afb97c7a102b601a">isStopRequested</a> () const</td></tr>
<tr class="separator:a44fc5f3a250fb055afb97c7a102b601a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a7c467cd4a7d11aaa59d6f7e337c43" id="r_a63a7c467cd4a7d11aaa59d6f7e337c43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a63a7c467cd4a7d11aaa59d6f7e337c43">waitForWorkerToStop</a> ()</td></tr>
<tr class="separator:a63a7c467cd4a7d11aaa59d6f7e337c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42718fe9201bdb465dca6634e61278ae" id="r_a42718fe9201bdb465dca6634e61278ae"><td class="memItemLeft" align="right" valign="top">std::thread::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a42718fe9201bdb465dca6634e61278ae">getWorkerThreadId</a> () const</td></tr>
<tr class="separator:a42718fe9201bdb465dca6634e61278ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e496b69ec455ad225be0cbabf84739" id="r_a37e496b69ec455ad225be0cbabf84739"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph_1_1editor_1_1_buffered_frame_info.html">BufferedFrameInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37e496b69ec455ad225be0cbabf84739">getFrameInfo</a> (const bool shouldIncludeDetails=false) const</td></tr>
<tr class="separator:a37e496b69ec455ad225be0cbabf84739"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>, typename... Args&gt;<br />
class ph::editor::TFrameWorkerThread&lt; NUM_BUFFERS, R(Args...)&gt;</div><p>A worker thread that helps to develop the concept of frame-to-frame work which is executed on another thread. For unbuffered frames, you can specify <code>NUM_BUFFERS = 1</code>, though one might consider to use <code><a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">TUnbufferedFrameWorkerThread</a></code> for this as it is specialized for this case and can offer better performance. Note that in <code><a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">TFrameWorkerThread</a></code>, works will not be processed until <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code> is called, while in <code><a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">TUnbufferedFrameWorkerThread</a></code> works will start being processed right after <code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code>.</p>
<p>Regarding thread safety notes:</p>
<p>Parent Thread: Thread that starts the worker thread (by calling <code><a class="el" href="#aeccac1b02007ffec04f9a1ac7a8ea564" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code>). Worker Thread: Thread that processes/consumes work, only one worker thread will be spawned. Producer Thread: Thread that adds/produces work, can be one or more. For a non-parent producer thread, it must synchronize with <code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code> and <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code>. Thread Safe: Can be used on any thread. Anything that has no thread safety notes: It is <b>NOT</b> thread safe.</p>
<p>A typical call sequence of the class would be like:</p>
<p>ctor call <code><a class="el" href="#aeccac1b02007ffec04f9a1ac7a8ea564" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code> one or more calls to:</p><ul>
<li><code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code></li>
<li>any number of calls to <code><a class="el" href="#ab94d36143ba6f4154e1fa10a4c0aed20">addWork()</a></code></li>
<li>possibly call <code><a class="el" href="#aa90935fc18ecbabdebe864c4b4f272c5" title="Ask the worker thread to stop. The worker thread will stop as soon as possible. Currently processing ...">requestWorkerStop()</a></code> or <code>waitAllWorks()</code></li>
<li><code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code> <code><a class="el" href="#a63a7c467cd4a7d11aaa59d6f7e337c43">waitForWorkerToStop()</a></code> dtor call</li>
</ul>
<p>It is the programmer's responsibility to make sure the class instance outlive the worker's full working cycle&ndash;from <code><a class="el" href="#aeccac1b02007ffec04f9a1ac7a8ea564" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code> to <code><a class="el" href="#a63a7c467cd4a7d11aaa59d6f7e337c43">waitForWorkerToStop()</a></code>. Ctor and dtor calls are not thread safe.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">NUM_BUFFERS</td><td>Number of buffered frames. For example, 1 corresponds to single buffering which forces the worker to wait until the work producer is done; 2 corresponds to double buffering where the worker and the work producer may have their own buffer (frame) to work on. Any number of buffers are supported. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a977e8183004ac999d670215e3bc90d78" name="a977e8183004ac999d670215e3bc90d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a977e8183004ac999d670215e3bc90d78">&#9670;&#160;</a></span>Work</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::Work = TFunction&lt;<a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="abd4665d907aa02a05c9d8ff2d5f4d982" name="abd4665d907aa02a05c9d8ff2d5f4d982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4665d907aa02a05c9d8ff2d5f4d982">&#9670;&#160;</a></span>TFrameWorkerThread() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::TFrameWorkerThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ed8a66b43938d09af0c53c37b0c15a9" name="a0ed8a66b43938d09af0c53c37b0c15a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed8a66b43938d09af0c53c37b0c15a9">&#9670;&#160;</a></span>TFrameWorkerThread() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::TFrameWorkerThread </td>
          <td>(</td>
          <td class="paramtype">bool</td>          <td class="paramname"><span class="paramname"><em>shouldFlushBufferBeforeStop</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does not start the worker thread. Worker thread can be started by calling <code><a class="el" href="#aeccac1b02007ffec04f9a1ac7a8ea564" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shouldFlushBufferBeforeStop</td><td>Whether all submitted works in the remaining frames should be processed before actually stopping the worker. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65bfdacf5c15c20f9390dfbd0a89b6a5" name="a65bfdacf5c15c20f9390dfbd0a89b6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65bfdacf5c15c20f9390dfbd0a89b6a5">&#9670;&#160;</a></span>~TFrameWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::~<a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">TFrameWorkerThread</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Must call <code><a class="el" href="#a63a7c467cd4a7d11aaa59d6f7e337c43">waitForWorkerToStop()</a></code> before reaching dtor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab94d36143ba6f4154e1fa10a4c0aed20" name="ab94d36143ba6f4154e1fa10a4c0aed20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab94d36143ba6f4154e1fa10a4c0aed20">&#9670;&#160;</a></span>addWork() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::addWork </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>workFunc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="#ad8a17998c6c5868dca6c82cc09331424" title="Adds a work that will be executed on the worker thread. Can only be called after the frame begins and...">addWork(Work)</a>. This variant supports general functors. Larger functors or non-trivial functors will induce additional overhead on creating and processing of the work. If you want to ensure minimal overhead, adhere to the binding requirements imposed by <code>TFunction</code>. </p><dl class="section note"><dt>Note</dt><dd>Producer threads only. Work objects will be destructed (if required) on worker thread. </dd></dl>

</div>
</div>
<a id="ad8a17998c6c5868dca6c82cc09331424" name="ad8a17998c6c5868dca6c82cc09331424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a17998c6c5868dca6c82cc09331424">&#9670;&#160;</a></span>addWork() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::addWork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a977e8183004ac999d670215e3bc90d78">Work</a></td>          <td class="paramname"><span class="paramname"><em>work</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a work that will be executed on the worker thread. Can only be called after the frame begins and before the frame ends, i.e., between calls to <code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code> and <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code>. Additionally, calling from frame callbacks such as <code><a class="el" href="#a5c80a273319fd3e84fbbed0c5c1f8ebe" title="Called right after the frame begins.">onBeginFrame()</a></code> and <code><a class="el" href="#a234f8a4fe9693f7c85d6e8cd197fa8e6" title="Called right before the frame ends.">onEndFrame()</a></code> is also allowed. </p>
<dl class="section note"><dt>Note</dt><dd>Producer threads only. </dd></dl>

</div>
</div>
<a id="ae01fc47788fe7c65a8300d2d66fd9720" name="ae01fc47788fe7c65a8300d2d66fd9720"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae01fc47788fe7c65a8300d2d66fd9720">&#9670;&#160;</a></span>beginFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::beginFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a new frame of works. All works added from previous frame are either being processing or finished after this call (depending on NUM_BUFFERS). Will potentially wait for works to complete. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<a id="a2c961f276e1af646dc807d50697f66af" name="a2c961f276e1af646dc807d50697f66af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c961f276e1af646dc807d50697f66af">&#9670;&#160;</a></span>endFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::endFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End this frame and works are submitted to the worker for processing. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<a id="a37e496b69ec455ad225be0cbabf84739" name="a37e496b69ec455ad225be0cbabf84739"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e496b69ec455ad225be0cbabf84739">&#9670;&#160;</a></span>getFrameInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph_1_1editor_1_1_buffered_frame_info.html">BufferedFrameInfo</a> <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::getFrameInfo </td>
          <td>(</td>
          <td class="paramtype">const bool</td>          <td class="paramname"><span class="paramname"><em>shouldIncludeDetails</em></span><span class="paramdefsep"> = </span><span class="paramdefval">false</span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get information about current frame. Can only be called between <code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code> and <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">shouldIncludeDetails</td><td>Flag for filling the detailed frame information, which incurs non-negligible overhead comparing to not filling. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Producer threads only. </dd></dl>

</div>
</div>
<a id="a42718fe9201bdb465dca6634e61278ae" name="a42718fe9201bdb465dca6634e61278ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42718fe9201bdb465dca6634e61278ae">&#9670;&#160;</a></span>getWorkerThreadId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread::id <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::getWorkerThreadId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a44fc5f3a250fb055afb97c7a102b601a" name="a44fc5f3a250fb055afb97c7a102b601a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fc5f3a250fb055afb97c7a102b601a">&#9670;&#160;</a></span>isStopRequested()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::isStopRequested </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a05a317731cb316946ab9afd157d95587" name="a05a317731cb316946ab9afd157d95587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05a317731cb316946ab9afd157d95587">&#9670;&#160;</a></span>onAsyncProcessWork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onAsyncProcessWork </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a977e8183004ac999d670215e3bc90d78">Work</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>work</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when each work is extracted and is going to be processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>The work to be processed. How to process it depends on the implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Called on worker thread only. </dd></dl>

</div>
</div>
<a id="a9d62a9f305615a9356f4af8ffc0bc911" name="a9d62a9f305615a9356f4af8ffc0bc911"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d62a9f305615a9356f4af8ffc0bc911">&#9670;&#160;</a></span>onAsyncWorkerStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onAsyncWorkerStart </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the worker has started. </p>
<dl class="section note"><dt>Note</dt><dd>Called on worker thread only. </dd></dl>

</div>
</div>
<a id="a94e00dbbe244c932751963a9b8d55861" name="a94e00dbbe244c932751963a9b8d55861"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e00dbbe244c932751963a9b8d55861">&#9670;&#160;</a></span>onAsyncWorkerStop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onAsyncWorkerStop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the worker has stopped. </p>
<dl class="section note"><dt>Note</dt><dd>Called on worker thread only. </dd></dl>

</div>
</div>
<a id="a5c80a273319fd3e84fbbed0c5c1f8ebe" name="a5c80a273319fd3e84fbbed0c5c1f8ebe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c80a273319fd3e84fbbed0c5c1f8ebe">&#9670;&#160;</a></span>onBeginFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onBeginFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called right after the frame begins. </p>
<dl class="section note"><dt>Note</dt><dd>Called on parent thread only. </dd></dl>

</div>
</div>
<a id="a234f8a4fe9693f7c85d6e8cd197fa8e6" name="a234f8a4fe9693f7c85d6e8cd197fa8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234f8a4fe9693f7c85d6e8cd197fa8e6">&#9670;&#160;</a></span>onEndFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onEndFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called right before the frame ends. </p>
<dl class="section note"><dt>Note</dt><dd>Called on parent thread only. </dd></dl>

</div>
</div>
<a id="aa90935fc18ecbabdebe864c4b4f272c5" name="aa90935fc18ecbabdebe864c4b4f272c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90935fc18ecbabdebe864c4b4f272c5">&#9670;&#160;</a></span>requestWorkerStop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::requestWorkerStop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask the worker thread to stop. The worker thread will stop as soon as possible. Currently processing frame will still complete before the worker stop. Whether works in buffered frames will be executed or not depends on the value of <code>shouldFlushBufferedWorksBeforeStop</code> specified to ctor. Can only be called between <code><a class="el" href="#ae01fc47788fe7c65a8300d2d66fd9720">beginFrame()</a></code> and <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code>. Works can still be added after this call. </p>
<dl class="section note"><dt>Note</dt><dd>Parent thread only. This is a request only, no memory effect is implied. </dd></dl>

</div>
</div>
<a id="aeccac1b02007ffec04f9a1ac7a8ea564" name="aeccac1b02007ffec04f9a1ac7a8ea564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccac1b02007ffec04f9a1ac7a8ea564">&#9670;&#160;</a></span>startWorker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::startWorker </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the worker. Call to this method synchronizes-with the execution of the worker thread. This method should not be called in the ctor as the worker thread will call virtual methods internally, which leads to possible UB if any derived class has not been initialized yet. </p>
<dl class="section note"><dt>Note</dt><dd>The thread that calls this method is considered the worker's parent thread. </dd></dl>

</div>
</div>
<a id="a63a7c467cd4a7d11aaa59d6f7e337c43" name="a63a7c467cd4a7d11aaa59d6f7e337c43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a7c467cd4a7d11aaa59d6f7e337c43">&#9670;&#160;</a></span>waitForWorkerToStop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t NUM_BUFFERS, typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">ph::editor::TFrameWorkerThread</a>&lt; NUM_BUFFERS, <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::waitForWorkerToStop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All operations on the worker thread will be done after this call returns. Can only be called after <code><a class="el" href="#a2c961f276e1af646dc807d50697f66af">endFrame()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Source/EditorCore/Thread/<a class="el" href="_t_frame_worker_thread_8h_source.html">TFrameWorkerThread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="namespaceph_1_1editor.html">editor</a></li><li class="navelem"><a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread_3_01_n_u_m___b_u_f_f_e_r_s_00_01_r_07_args_8_8_8_08_4.html">TFrameWorkerThread&lt; NUM_BUFFERS, R(Args...)&gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
