<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon Editor Library: ph::editor::TUnbufferedFrameWorkerThread&lt; R(Args...)&gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<!-- Add a link to project GitHub by https://tholman.com/github-corners/ -->
<a href="https://github.com/TzuChieh/Photon-v2" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Photon Editor Library<span id="projectnumber">&#160;2.0.0-beta</span>
   </div>
   <div id="projectbrief">A physically based renderer.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classph_1_1editor_1_1_t_unbuffered_frame_worker_thread_3_01_r_07_args_8_8_8_08_4.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread_3_01_r_07_args_8_8_8_08_4-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ph::editor::TUnbufferedFrameWorkerThread&lt; R(Args...)&gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_t_unbuffered_frame_worker_thread_8h_source.html">TUnbufferedFrameWorkerThread.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ph::editor::TUnbufferedFrameWorkerThread&lt; R(Args...)&gt;:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread_3_01_r_07_args_8_8_8_08_4.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5c960283bb8ae57249b28c9ae905d035" id="r_a5c960283bb8ae57249b28c9ae905d035"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5c960283bb8ae57249b28c9ae905d035">Work</a> = TFunction&lt;<a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;</td></tr>
<tr class="separator:a5c960283bb8ae57249b28c9ae905d035"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a24ab137e444f496cf23a214006d02e69" id="r_a24ab137e444f496cf23a214006d02e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24ab137e444f496cf23a214006d02e69">TUnbufferedFrameWorkerThread</a> ()</td></tr>
<tr class="separator:a24ab137e444f496cf23a214006d02e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b1366c4399e2ade991b3ca3f451762" id="r_aa0b1366c4399e2ade991b3ca3f451762"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa0b1366c4399e2ade991b3ca3f451762">~TUnbufferedFrameWorkerThread</a> ()</td></tr>
<tr class="separator:aa0b1366c4399e2ade991b3ca3f451762"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6782e98c1c57dd7f7b0c5dceee00c3c" id="r_ad6782e98c1c57dd7f7b0c5dceee00c3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad6782e98c1c57dd7f7b0c5dceee00c3c">onAsyncProcessWork</a> (const <a class="el" href="#a5c960283bb8ae57249b28c9ae905d035">Work</a> &amp;work)=0</td></tr>
<tr class="memdesc:ad6782e98c1c57dd7f7b0c5dceee00c3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when each work is extracted and is going to be processed.  <br /></td></tr>
<tr class="separator:ad6782e98c1c57dd7f7b0c5dceee00c3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae90b3ec11259ea2ce9777eb4efdf6560" id="r_ae90b3ec11259ea2ce9777eb4efdf6560"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae90b3ec11259ea2ce9777eb4efdf6560">onAsyncWorkerStart</a> ()</td></tr>
<tr class="memdesc:ae90b3ec11259ea2ce9777eb4efdf6560"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the worker has started.  <br /></td></tr>
<tr class="separator:ae90b3ec11259ea2ce9777eb4efdf6560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe15240992abb74ca5d9fe0a399c81a9" id="r_afe15240992abb74ca5d9fe0a399c81a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe15240992abb74ca5d9fe0a399c81a9">onAsyncWorkerStop</a> ()</td></tr>
<tr class="memdesc:afe15240992abb74ca5d9fe0a399c81a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called when the worker has stopped.  <br /></td></tr>
<tr class="separator:afe15240992abb74ca5d9fe0a399c81a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a742d5ec4a1ebb5ca990477f072790704" id="r_a742d5ec4a1ebb5ca990477f072790704"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a742d5ec4a1ebb5ca990477f072790704">onBeginFrame</a> ()</td></tr>
<tr class="memdesc:a742d5ec4a1ebb5ca990477f072790704"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called right after the frame begins.  <br /></td></tr>
<tr class="separator:a742d5ec4a1ebb5ca990477f072790704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76cf376717839663132c082e03b47244" id="r_a76cf376717839663132c082e03b47244"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76cf376717839663132c082e03b47244">onEndFrame</a> ()</td></tr>
<tr class="memdesc:a76cf376717839663132c082e03b47244"><td class="mdescLeft">&#160;</td><td class="mdescRight">Called right before the frame ends.  <br /></td></tr>
<tr class="separator:a76cf376717839663132c082e03b47244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825e523a69770b1e2eb06d6360bd5d10" id="r_a825e523a69770b1e2eb06d6360bd5d10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a825e523a69770b1e2eb06d6360bd5d10">startWorker</a> ()</td></tr>
<tr class="memdesc:a825e523a69770b1e2eb06d6360bd5d10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the worker. Call to this method synchronizes-with the execution of the worker thread. This method should not be called in the ctor as the worker thread will call virtual methods internally, which leads to possible UB if any derived class has not been initialized yet.  <br /></td></tr>
<tr class="separator:a825e523a69770b1e2eb06d6360bd5d10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abae382c92b3f5e253bc2c3d6b325ad3d" id="r_abae382c92b3f5e253bc2c3d6b325ad3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame</a> ()</td></tr>
<tr class="separator:abae382c92b3f5e253bc2c3d6b325ad3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403d0bbbc93e2805fbdcdd159e847585" id="r_a403d0bbbc93e2805fbdcdd159e847585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame</a> ()</td></tr>
<tr class="separator:a403d0bbbc93e2805fbdcdd159e847585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a916b54879baaff1252b97aabc0316510" id="r_a916b54879baaff1252b97aabc0316510"><td class="memTemplParams" colspan="2">template&lt;typename Func &gt; </td></tr>
<tr class="memitem:a916b54879baaff1252b97aabc0316510"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a916b54879baaff1252b97aabc0316510">addWork</a> (Func &amp;&amp;workFunc)</td></tr>
<tr class="separator:a916b54879baaff1252b97aabc0316510"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0deb98b4c017e1e0d1bf1f689a04aaa3" id="r_a0deb98b4c017e1e0d1bf1f689a04aaa3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0deb98b4c017e1e0d1bf1f689a04aaa3">addWork</a> (<a class="el" href="#a5c960283bb8ae57249b28c9ae905d035">Work</a> work)</td></tr>
<tr class="memdesc:a0deb98b4c017e1e0d1bf1f689a04aaa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds a work that will be executed on the worker thread. Can only be called after the frame begins and before the frame ends, i.e., between calls to <code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code> and <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. Additionally, calling from frame callbacks such as <code><a class="el" href="#a742d5ec4a1ebb5ca990477f072790704" title="Called right after the frame begins.">onBeginFrame()</a></code> and <code><a class="el" href="#a76cf376717839663132c082e03b47244" title="Called right before the frame ends.">onEndFrame()</a></code> is also allowed.  <br /></td></tr>
<tr class="separator:a0deb98b4c017e1e0d1bf1f689a04aaa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc66d0262acfdfb4e5b7f1b5bba5c5b1" id="r_abc66d0262acfdfb4e5b7f1b5bba5c5b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abc66d0262acfdfb4e5b7f1b5bba5c5b1">waitAllWorks</a> ()</td></tr>
<tr class="memdesc:abc66d0262acfdfb4e5b7f1b5bba5c5b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all added works to finish. Can only be called after the frame begins and before the frame ends, i.e., between calls to <code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code> and <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. Additionally, calling from frame callbacks such as <code><a class="el" href="#a742d5ec4a1ebb5ca990477f072790704" title="Called right after the frame begins.">onBeginFrame()</a></code> and <code><a class="el" href="#a76cf376717839663132c082e03b47244" title="Called right before the frame ends.">onEndFrame()</a></code> is also allowed. Memory effects on worker thread are made visible to the parent thread.  <br /></td></tr>
<tr class="separator:abc66d0262acfdfb4e5b7f1b5bba5c5b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b9732422e177dffab30f3482e26fac6" id="r_a9b9732422e177dffab30f3482e26fac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b9732422e177dffab30f3482e26fac6">requestWorkerStop</a> ()</td></tr>
<tr class="memdesc:a9b9732422e177dffab30f3482e26fac6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ask the worker thread to stop. The worker thread will stop as soon as possible. Currently processing frame will still complete before the worker stop. Can only be called between <code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code> and <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. Works can still be added after this call.  <br /></td></tr>
<tr class="separator:a9b9732422e177dffab30f3482e26fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c45c12ad8661d3843cf5736da970874" id="r_a3c45c12ad8661d3843cf5736da970874"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3c45c12ad8661d3843cf5736da970874">isStopRequested</a> () const</td></tr>
<tr class="separator:a3c45c12ad8661d3843cf5736da970874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c0fdcf188545a038919dce689358c5" id="r_a70c0fdcf188545a038919dce689358c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70c0fdcf188545a038919dce689358c5">waitForWorkerToStop</a> ()</td></tr>
<tr class="separator:a70c0fdcf188545a038919dce689358c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74edc43af1758c9524972447cea79041" id="r_a74edc43af1758c9524972447cea79041"><td class="memItemLeft" align="right" valign="top">std::thread::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74edc43af1758c9524972447cea79041">getWorkerThreadId</a> () const</td></tr>
<tr class="separator:a74edc43af1758c9524972447cea79041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c764c6e701198d108928fed92a49db" id="r_a07c764c6e701198d108928fed92a49db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structph_1_1editor_1_1_unbuffered_frame_info.html">UnbufferedFrameInfo</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07c764c6e701198d108928fed92a49db">getFrameInfo</a> () const</td></tr>
<tr class="separator:a07c764c6e701198d108928fed92a49db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>, typename... Args&gt;<br />
class ph::editor::TUnbufferedFrameWorkerThread&lt; R(Args...)&gt;</div><p>A worker thread that helps to develop the concept of frame-to-frame work which is executed on another thread. Unlike its variant, <code><a class="el" href="classph_1_1editor_1_1_t_frame_worker_thread.html">TFrameWorkerThread</a></code>, this class has no buffer and works added will be processed as soon as possible (no need to wait for the call to <a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a>).</p>
<p>Regarding thread safety notes:</p>
<p>Parent Thread: Thread that starts the worker thread (by calling <code><a class="el" href="#a825e523a69770b1e2eb06d6360bd5d10" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code>). Worker Thread: Thread that processes/consumes work, only one worker thread will be spawned. Thread Safe: Can be used on any thread. Anything that has no thread safety notes: It is <b>NOT</b> thread safe.</p>
<p>A typical call sequence of the class would be like:</p>
<p>ctor call <code><a class="el" href="#a825e523a69770b1e2eb06d6360bd5d10" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code> one or more calls to:</p><ul>
<li><code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code></li>
<li>any number of calls to <code><a class="el" href="#a916b54879baaff1252b97aabc0316510">addWork()</a></code></li>
<li>possibly call <code><a class="el" href="#a9b9732422e177dffab30f3482e26fac6" title="Ask the worker thread to stop. The worker thread will stop as soon as possible. Currently processing ...">requestWorkerStop()</a></code></li>
<li><code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code> <code><a class="el" href="#a70c0fdcf188545a038919dce689358c5">waitForWorkerToStop()</a></code> dtor call</li>
</ul>
<p>It is the programmer's responsibility to make sure the class instance outlive the worker's full working cycle&ndash;from <code><a class="el" href="#a825e523a69770b1e2eb06d6360bd5d10" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code> to <code><a class="el" href="#a70c0fdcf188545a038919dce689358c5">waitForWorkerToStop()</a></code>. Ctor and dtor calls are not thread safe. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a5c960283bb8ae57249b28c9ae905d035" name="a5c960283bb8ae57249b28c9ae905d035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c960283bb8ae57249b28c9ae905d035">&#9670;&#160;</a></span>Work</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::Work = TFunction&lt;<a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a24ab137e444f496cf23a214006d02e69" name="a24ab137e444f496cf23a214006d02e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24ab137e444f496cf23a214006d02e69">&#9670;&#160;</a></span>TUnbufferedFrameWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::TUnbufferedFrameWorkerThread </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does not start the worker thread. Worker thread can be started by calling <code><a class="el" href="#a825e523a69770b1e2eb06d6360bd5d10" title="Start the worker. Call to this method synchronizes-with the execution of the worker thread....">startWorker()</a></code>. </p>

</div>
</div>
<a id="aa0b1366c4399e2ade991b3ca3f451762" name="aa0b1366c4399e2ade991b3ca3f451762"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0b1366c4399e2ade991b3ca3f451762">&#9670;&#160;</a></span>~TUnbufferedFrameWorkerThread()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::~<a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">TUnbufferedFrameWorkerThread</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Must call <code><a class="el" href="#a70c0fdcf188545a038919dce689358c5">waitForWorkerToStop()</a></code> before reaching dtor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a916b54879baaff1252b97aabc0316510" name="a916b54879baaff1252b97aabc0316510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a916b54879baaff1252b97aabc0316510">&#9670;&#160;</a></span>addWork() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<div class="memtemplate">
template&lt;typename Func &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::addWork </td>
          <td>(</td>
          <td class="paramtype">Func &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>workFunc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Similar to <a class="el" href="#a0deb98b4c017e1e0d1bf1f689a04aaa3" title="Adds a work that will be executed on the worker thread. Can only be called after the frame begins and...">addWork(Work)</a>. This variant supports general functors. Larger functors or non-trivial functors will induce additional overhead on creating and processing of the work. If you want to ensure minimal overhead, adhere to the binding requirements imposed by <code>TFunction</code>. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. Work objects will be destructed (if required) on worker thread. </dd></dl>

</div>
</div>
<a id="a0deb98b4c017e1e0d1bf1f689a04aaa3" name="a0deb98b4c017e1e0d1bf1f689a04aaa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0deb98b4c017e1e0d1bf1f689a04aaa3">&#9670;&#160;</a></span>addWork() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::addWork </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5c960283bb8ae57249b28c9ae905d035">Work</a></td>          <td class="paramname"><span class="paramname"><em>work</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds a work that will be executed on the worker thread. Can only be called after the frame begins and before the frame ends, i.e., between calls to <code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code> and <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. Additionally, calling from frame callbacks such as <code><a class="el" href="#a742d5ec4a1ebb5ca990477f072790704" title="Called right after the frame begins.">onBeginFrame()</a></code> and <code><a class="el" href="#a76cf376717839663132c082e03b47244" title="Called right before the frame ends.">onEndFrame()</a></code> is also allowed. </p>
<dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<a id="abae382c92b3f5e253bc2c3d6b325ad3d" name="abae382c92b3f5e253bc2c3d6b325ad3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abae382c92b3f5e253bc2c3d6b325ad3d">&#9670;&#160;</a></span>beginFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::beginFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Start a new frame of works. All works added from previous frame are finished after this call and memory effects are made visible to the parent thread. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<a id="a403d0bbbc93e2805fbdcdd159e847585" name="a403d0bbbc93e2805fbdcdd159e847585"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403d0bbbc93e2805fbdcdd159e847585">&#9670;&#160;</a></span>endFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::endFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>End this frame. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<a id="a07c764c6e701198d108928fed92a49db" name="a07c764c6e701198d108928fed92a49db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c764c6e701198d108928fed92a49db">&#9670;&#160;</a></span>getFrameInfo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structph_1_1editor_1_1_unbuffered_frame_info.html">UnbufferedFrameInfo</a> <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::getFrameInfo </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get information about current frame. Can only be called between <code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code> and <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<a id="a74edc43af1758c9524972447cea79041" name="a74edc43af1758c9524972447cea79041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74edc43af1758c9524972447cea79041">&#9670;&#160;</a></span>getWorkerThreadId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread::id <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::getWorkerThreadId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a3c45c12ad8661d3843cf5736da970874" name="a3c45c12ad8661d3843cf5736da970874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c45c12ad8661d3843cf5736da970874">&#9670;&#160;</a></span>isStopRequested()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::isStopRequested </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="ad6782e98c1c57dd7f7b0c5dceee00c3c" name="ad6782e98c1c57dd7f7b0c5dceee00c3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6782e98c1c57dd7f7b0c5dceee00c3c">&#9670;&#160;</a></span>onAsyncProcessWork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onAsyncProcessWork </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="#a5c960283bb8ae57249b28c9ae905d035">Work</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>work</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when each work is extracted and is going to be processed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">work</td><td>The work to be processed. How to process it depends on the implementation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Called on worker thread only. </dd></dl>

</div>
</div>
<a id="ae90b3ec11259ea2ce9777eb4efdf6560" name="ae90b3ec11259ea2ce9777eb4efdf6560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae90b3ec11259ea2ce9777eb4efdf6560">&#9670;&#160;</a></span>onAsyncWorkerStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onAsyncWorkerStart </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the worker has started. </p>
<dl class="section note"><dt>Note</dt><dd>Called on worker thread only. </dd></dl>

</div>
</div>
<a id="afe15240992abb74ca5d9fe0a399c81a9" name="afe15240992abb74ca5d9fe0a399c81a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe15240992abb74ca5d9fe0a399c81a9">&#9670;&#160;</a></span>onAsyncWorkerStop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onAsyncWorkerStop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called when the worker has stopped. </p>
<dl class="section note"><dt>Note</dt><dd>Called on worker thread only. </dd></dl>

</div>
</div>
<a id="a742d5ec4a1ebb5ca990477f072790704" name="a742d5ec4a1ebb5ca990477f072790704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a742d5ec4a1ebb5ca990477f072790704">&#9670;&#160;</a></span>onBeginFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onBeginFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called right after the frame begins. </p>
<dl class="section note"><dt>Note</dt><dd>Called on parent thread only. </dd></dl>

</div>
</div>
<a id="a76cf376717839663132c082e03b47244" name="a76cf376717839663132c082e03b47244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76cf376717839663132c082e03b47244">&#9670;&#160;</a></span>onEndFrame()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::onEndFrame </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Called right before the frame ends. </p>
<dl class="section note"><dt>Note</dt><dd>Called on parent thread only. </dd></dl>

</div>
</div>
<a id="a9b9732422e177dffab30f3482e26fac6" name="a9b9732422e177dffab30f3482e26fac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b9732422e177dffab30f3482e26fac6">&#9670;&#160;</a></span>requestWorkerStop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::requestWorkerStop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Ask the worker thread to stop. The worker thread will stop as soon as possible. Currently processing frame will still complete before the worker stop. Can only be called between <code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code> and <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. Works can still be added after this call. </p>
<dl class="section note"><dt>Note</dt><dd>Parent thread only. This is a request only, no memory effect is implied. </dd></dl>

</div>
</div>
<a id="a825e523a69770b1e2eb06d6360bd5d10" name="a825e523a69770b1e2eb06d6360bd5d10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825e523a69770b1e2eb06d6360bd5d10">&#9670;&#160;</a></span>startWorker()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::startWorker </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the worker. Call to this method synchronizes-with the execution of the worker thread. This method should not be called in the ctor as the worker thread will call virtual methods internally, which leads to possible UB if any derived class has not been initialized yet. </p>
<dl class="section note"><dt>Note</dt><dd>The thread that calls this method is considered the worker's parent thread. </dd></dl>

</div>
</div>
<a id="abc66d0262acfdfb4e5b7f1b5bba5c5b1" name="abc66d0262acfdfb4e5b7f1b5bba5c5b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc66d0262acfdfb4e5b7f1b5bba5c5b1">&#9670;&#160;</a></span>waitAllWorks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::waitAllWorks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all added works to finish. Can only be called after the frame begins and before the frame ends, i.e., between calls to <code><a class="el" href="#abae382c92b3f5e253bc2c3d6b325ad3d">beginFrame()</a></code> and <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. Additionally, calling from frame callbacks such as <code><a class="el" href="#a742d5ec4a1ebb5ca990477f072790704" title="Called right after the frame begins.">onBeginFrame()</a></code> and <code><a class="el" href="#a76cf376717839663132c082e03b47244" title="Called right before the frame ends.">onEndFrame()</a></code> is also allowed. Memory effects on worker thread are made visible to the parent thread. </p>
<dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<a id="a70c0fdcf188545a038919dce689358c5" name="a70c0fdcf188545a038919dce689358c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c0fdcf188545a038919dce689358c5">&#9670;&#160;</a></span>waitForWorkerToStop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a> , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread.html">ph::editor::TUnbufferedFrameWorkerThread</a>&lt; <a class="el" href="namespaceph_1_1editor.html#a8416c0e2549730bba9233b7ab6413c68ae1e1d3d40573127e9ee0480caf1283d6">R</a>(Args...)&gt;::waitForWorkerToStop </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All operations on the worker thread will be done after this call returns. Can only be called after <code><a class="el" href="#a403d0bbbc93e2805fbdcdd159e847585">endFrame()</a></code>. </p><dl class="section note"><dt>Note</dt><dd>Parent thread only. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>Source/EditorCore/Thread/<a class="el" href="_t_unbuffered_frame_worker_thread_8h_source.html">TUnbufferedFrameWorkerThread.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="namespaceph_1_1editor.html">editor</a></li><li class="navelem"><a class="el" href="classph_1_1editor_1_1_t_unbuffered_frame_worker_thread_3_01_r_07_args_8_8_8_08_4.html">TUnbufferedFrameWorkerThread&lt; R(Args...)&gt;</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
