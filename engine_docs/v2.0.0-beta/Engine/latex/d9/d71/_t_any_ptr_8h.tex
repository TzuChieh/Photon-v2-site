\doxysection{Source/\+Utility/\+TAny\+Ptr.h File Reference}
\hypertarget{_t_any_ptr_8h}{}\label{_t_any_ptr_8h}\index{Source/Utility/TAnyPtr.h@{Source/Utility/TAnyPtr.h}}
{\ttfamily \#include $<$utility$>$}\newline
{\ttfamily \#include $<$cstddef$>$}\newline
{\ttfamily \#include $<$type\+\_\+traits$>$}\newline
{\ttfamily \#include $<$typeindex$>$}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classph_1_1_t_any_ptr}{ph\+::\+TAny\+Ptr$<$ IS\+\_\+\+CONST $>$}}
\begin{DoxyCompactList}\small\item\em A type-\/safe, lightweight wrapper for any raw pointer type. Using {\ttfamily std\+::any} with a raw pointer type could achieve similar functionality. However, this class is dedicated for raw pointers and is guaranteed to have no dynamic allocation. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceph}{ph}}
\begin{DoxyCompactList}\small\item\em The root for all renderer implementations. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using \mbox{\hyperlink{namespaceph_a14bed083c6df9bb5fc25512fdf352484}{ph\+::\+Any\+Const\+Ptr}} = \mbox{\hyperlink{classph_1_1_t_any_ptr}{TAny\+Ptr}}$<$ true $>$
\begin{DoxyCompactList}\small\item\em A type-\/safe, lightweight wrapper for any const raw pointer type. \end{DoxyCompactList}\item 
using \mbox{\hyperlink{namespaceph_a76393562caa22c28431e3d8da5706a2b}{ph\+::\+Any\+Non\+Const\+Ptr}} = \mbox{\hyperlink{classph_1_1_t_any_ptr}{TAny\+Ptr}}$<$ false $>$
\begin{DoxyCompactList}\small\item\em A type-\/safe, lightweight wrapper for any non-\/const raw pointer type. \end{DoxyCompactList}\end{DoxyCompactItemize}
