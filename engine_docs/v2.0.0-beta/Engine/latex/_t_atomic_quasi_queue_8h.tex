\doxysection{Source/\+Utility/\+Concurrent/\+TAtomic\+Quasi\+Queue.h File Reference}
\hypertarget{_t_atomic_quasi_queue_8h}{}\label{_t_atomic_quasi_queue_8h}\index{Source/Utility/Concurrent/TAtomicQuasiQueue.h@{Source/Utility/Concurrent/TAtomicQuasiQueue.h}}
{\ttfamily \#include $<$Common/config.\+h$>$}\newline
{\ttfamily \#include $<$moodycamel/concurrentqueue.\+h$>$}\newline
{\ttfamily \#include $<$cstddef$>$}\newline
{\ttfamily \#include $<$iterator$>$}\newline
{\ttfamily \#include "{}Utility/\+Concurrent/\+TAtomic\+Quasi\+Queue.\+ipp"{}}\newline
\doxysubsubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class \mbox{\hyperlink{classph_1_1_t_atomic_quasi_queue}{ph\+::\+TAtomic\+Quasi\+Queue$<$ T $>$}}
\begin{DoxyCompactList}\small\item\em A multi-\/producer, multi-\/consumer, lock-\/free concurrent queue-\/like structure. For single-\/thread uses, it is a FIFO queue. For multi-\/thread uses, it is {\itshape mostly} a FIFO queue. Specifically, items put in by a given producer will all come out in the same order (FIFO). But there is no coordination between items from other producers--two items put in by two different producers will come out in an undefined order relative to each other (the interleaving between different streams of items from different producers is undefined, even with external synchronization). It is possible some items will starve in the queue if more items are enqueued than dequeued. Guarantees aquire-\/release semantics for items that are enqueued/dequeued. \end{DoxyCompactList}\end{DoxyCompactItemize}
\doxysubsubsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
namespace \mbox{\hyperlink{namespaceph}{ph}}
\begin{DoxyCompactList}\small\item\em The root for all renderer implementations. \end{DoxyCompactList}\end{DoxyCompactItemize}
