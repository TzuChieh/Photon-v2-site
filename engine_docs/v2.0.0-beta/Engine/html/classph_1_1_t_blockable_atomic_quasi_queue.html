<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon Engine: ph::TBlockableAtomicQuasiQueue&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<!-- Add a link to project GitHub by https://tholman.com/github-corners/ -->
<a href="https://github.com/TzuChieh/Photon-v2" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Photon Engine<span id="projectnumber">&#160;2.0.0-beta</span>
   </div>
   <div id="projectbrief">A physically based renderer.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classph_1_1_t_blockable_atomic_quasi_queue.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classph_1_1_t_blockable_atomic_quasi_queue-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ph::TBlockableAtomicQuasiQueue&lt; T &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>Blockable version of the <code><a class="el" href="classph_1_1_t_atomic_quasi_queue.html" title="A multi-producer, multi-consumer, lock-free concurrent queue-like structure. For single-thread uses,...">TAtomicQuasiQueue</a></code>. For single-thread uses, it is a FIFO queue. For multi-thread uses, it is <em>mostly</em> a FIFO queue. Specifically, items put in by a given producer will all come out in the same order (FIFO). But there is no coordination between items from other producers&ndash;two items put in by two different producers will come out in an undefined order relative to each other (the interleaving between different streams of items from different producers is undefined, even with external synchronization). It is possible some items will starve in the queue if more items are enqueued than dequeued. Guarantees aquire-release semantics for items that are enqueued/dequeued.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_t_blockable_atomic_quasi_queue_8h_source.html">TBlockableAtomicQuasiQueue.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6f61f4c07efc1d1ae4c425d2f2665eb" id="r_ab6f61f4c07efc1d1ae4c425d2f2665eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab6f61f4c07efc1d1ae4c425d2f2665eb">TBlockableAtomicQuasiQueue</a> ()</td></tr>
<tr class="separator:ab6f61f4c07efc1d1ae4c425d2f2665eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f47601b7414d4b1e5584614f229d8b0" id="r_a5f47601b7414d4b1e5584614f229d8b0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5f47601b7414d4b1e5584614f229d8b0">TBlockableAtomicQuasiQueue</a> (std::size_t initialCapacity)</td></tr>
<tr class="separator:a5f47601b7414d4b1e5584614f229d8b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb085a43e7de1339fbad15365b08c36d" id="r_abb085a43e7de1339fbad15365b08c36d"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:abb085a43e7de1339fbad15365b08c36d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abb085a43e7de1339fbad15365b08c36d">enqueue</a> (U &amp;&amp;item)</td></tr>
<tr class="memdesc:abb085a43e7de1339fbad15365b08c36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue an item. Allocate memory if required. Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by a thread before it enqueues an item will be visible on another thread after it dequeues that item. See <a class="el" href="#abccaa60269a3e0824eb94588f7fa4657" title="Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory...">tryDequeue(T*)</a> for how to ensure the item can be dequeued on another thread.  <br /></td></tr>
<tr class="separator:abb085a43e7de1339fbad15365b08c36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9837d99ddb32b7317f47de7a4174338a" id="r_a9837d99ddb32b7317f47de7a4174338a"><td class="memTemplParams" colspan="2">template&lt;std::input_iterator Iterator&gt; </td></tr>
<tr class="memitem:a9837d99ddb32b7317f47de7a4174338a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9837d99ddb32b7317f47de7a4174338a">enqueueBulk</a> (Iterator firstItem, std::size_t numItems)</td></tr>
<tr class="memdesc:a9837d99ddb32b7317f47de7a4174338a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enqueue multiple items at once. Similar to <code>enqueue(1)</code>. Use <code>std::make_move_iterator</code> if the items should be moved instead of copied.  <br /></td></tr>
<tr class="separator:a9837d99ddb32b7317f47de7a4174338a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac97cfcc51484bfd428b4db46e01d81" id="r_a1ac97cfcc51484bfd428b4db46e01d81"><td class="memTemplParams" colspan="2">template&lt;typename U &gt; </td></tr>
<tr class="memitem:a1ac97cfcc51484bfd428b4db46e01d81"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1ac97cfcc51484bfd428b4db46e01d81">tryEnqueue</a> (U &amp;&amp;item)</td></tr>
<tr class="memdesc:a1ac97cfcc51484bfd428b4db46e01d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to enqueue an item. Never allocate memory.  <br /></td></tr>
<tr class="separator:a1ac97cfcc51484bfd428b4db46e01d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abccaa60269a3e0824eb94588f7fa4657" id="r_abccaa60269a3e0824eb94588f7fa4657"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abccaa60269a3e0824eb94588f7fa4657">tryDequeue</a> (T *out_item)</td></tr>
<tr class="memdesc:abccaa60269a3e0824eb94588f7fa4657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory effect of enqueue is not visible. Dequeue can also fail spuriously if there is another consumer (under contention). To guarantee all enqueued items eventually got dequeued, memory effects must be made visible to the dequeuing threads.  <br /></td></tr>
<tr class="separator:abccaa60269a3e0824eb94588f7fa4657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab61d3af1feee2ebefd2ab5e7f90ddd79" id="r_ab61d3af1feee2ebefd2ab5e7f90ddd79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab61d3af1feee2ebefd2ab5e7f90ddd79">waitDequeue</a> (T *out_item)</td></tr>
<tr class="memdesc:ab61d3af1feee2ebefd2ab5e7f90ddd79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blocks the current thread until there is something to dequeue.  <br /></td></tr>
<tr class="separator:ab61d3af1feee2ebefd2ab5e7f90ddd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0004e99fc958f152e3bffd2af2589f7" id="r_ae0004e99fc958f152e3bffd2af2589f7"><td class="memTemplParams" colspan="2">template&lt;std::output_iterator&lt; T &gt; Iterator&gt; </td></tr>
<tr class="memitem:ae0004e99fc958f152e3bffd2af2589f7"><td class="memTemplItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae0004e99fc958f152e3bffd2af2589f7">waitDequeueBulk</a> (Iterator out_firstItem, std::size_t numItems)</td></tr>
<tr class="separator:ae0004e99fc958f152e3bffd2af2589f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd8f48f70e35b29c73cbef59ea5b9b3" id="r_abdd8f48f70e35b29c73cbef59ea5b9b3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abdd8f48f70e35b29c73cbef59ea5b9b3">estimatedSize</a> () const</td></tr>
<tr class="memdesc:abdd8f48f70e35b29c73cbef59ea5b9b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Approximated size of the queue.  <br /></td></tr>
<tr class="separator:abdd8f48f70e35b29c73cbef59ea5b9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename T&gt;<br />
class ph::TBlockableAtomicQuasiQueue&lt; T &gt;</div><p>Blockable version of the <code><a class="el" href="classph_1_1_t_atomic_quasi_queue.html" title="A multi-producer, multi-consumer, lock-free concurrent queue-like structure. For single-thread uses,...">TAtomicQuasiQueue</a></code>. For single-thread uses, it is a FIFO queue. For multi-thread uses, it is <em>mostly</em> a FIFO queue. Specifically, items put in by a given producer will all come out in the same order (FIFO). But there is no coordination between items from other producers&ndash;two items put in by two different producers will come out in an undefined order relative to each other (the interleaving between different streams of items from different producers is undefined, even with external synchronization). It is possible some items will starve in the queue if more items are enqueued than dequeued. Guarantees aquire-release semantics for items that are enqueued/dequeued. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6f61f4c07efc1d1ae4c425d2f2665eb" name="ab6f61f4c07efc1d1ae4c425d2f2665eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f61f4c07efc1d1ae4c425d2f2665eb">&#9670;&#160;</a></span>TBlockableAtomicQuasiQueue() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::TBlockableAtomicQuasiQueue </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5f47601b7414d4b1e5584614f229d8b0" name="a5f47601b7414d4b1e5584614f229d8b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f47601b7414d4b1e5584614f229d8b0">&#9670;&#160;</a></span>TBlockableAtomicQuasiQueue() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::TBlockableAtomicQuasiQueue </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>initialCapacity</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abb085a43e7de1339fbad15365b08c36d" name="abb085a43e7de1339fbad15365b08c36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb085a43e7de1339fbad15365b08c36d">&#9670;&#160;</a></span>enqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::enqueue </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue an item. Allocate memory if required. Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by a thread before it enqueues an item will be visible on another thread after it dequeues that item. See <a class="el" href="#abccaa60269a3e0824eb94588f7fa4657" title="Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory...">tryDequeue(T*)</a> for how to ensure the item can be dequeued on another thread. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a9837d99ddb32b7317f47de7a4174338a" name="a9837d99ddb32b7317f47de7a4174338a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9837d99ddb32b7317f47de7a4174338a">&#9670;&#160;</a></span>enqueueBulk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;std::input_iterator Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::enqueueBulk </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>firstItem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numItems</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enqueue multiple items at once. Similar to <code>enqueue(1)</code>. Use <code>std::make_move_iterator</code> if the items should be moved instead of copied. </p>

</div>
</div>
<a id="abdd8f48f70e35b29c73cbef59ea5b9b3" name="abdd8f48f70e35b29c73cbef59ea5b9b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd8f48f70e35b29c73cbef59ea5b9b3">&#9670;&#160;</a></span>estimatedSize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::estimatedSize </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Approximated size of the queue. </p>
<dl class="section return"><dt>Returns</dt><dd>Number of items in the queue. The esimation is only accurate if all memory writes to the queue is guaranteed to be visible. Note that 0 may be returned even if the queue is, in fact, not empty. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="abccaa60269a3e0824eb94588f7fa4657" name="abccaa60269a3e0824eb94588f7fa4657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abccaa60269a3e0824eb94588f7fa4657">&#9670;&#160;</a></span>tryDequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::tryDequeue </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out_item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to dequeue an item. While there is no contention, dequeue fails if there is no item or the memory effect of enqueue is not visible. Dequeue can also fail spuriously if there is another consumer (under contention). To guarantee all enqueued items eventually got dequeued, memory effects must be made visible to the dequeuing threads. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an item is dequeued. <code>false</code> otherwise (even if the queue is not empty). </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="a1ac97cfcc51484bfd428b4db46e01d81" name="a1ac97cfcc51484bfd428b4db46e01d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac97cfcc51484bfd428b4db46e01d81">&#9670;&#160;</a></span>tryEnqueue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::tryEnqueue </td>
          <td>(</td>
          <td class="paramtype">U &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Try to enqueue an item. Never allocate memory. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the item is enqueued. <code>false</code> otherwise. </dd></dl>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="ab61d3af1feee2ebefd2ab5e7f90ddd79" name="ab61d3af1feee2ebefd2ab5e7f90ddd79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab61d3af1feee2ebefd2ab5e7f90ddd79">&#9670;&#160;</a></span>waitDequeue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::waitDequeue </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out_item</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blocks the current thread until there is something to dequeue. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="ae0004e99fc958f152e3bffd2af2589f7" name="ae0004e99fc958f152e3bffd2af2589f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0004e99fc958f152e3bffd2af2589f7">&#9670;&#160;</a></span>waitDequeueBulk()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<div class="memtemplate">
template&lt;std::output_iterator&lt; T &gt; Iterator&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">ph::TBlockableAtomicQuasiQueue</a>&lt; T &gt;::waitDequeueBulk </td>
          <td>(</td>
          <td class="paramtype">Iterator</td>          <td class="paramname"><span class="paramname"><em>out_firstItem</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numItems</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/Utility/Concurrent/<a class="el" href="_t_blockable_atomic_quasi_queue_8h_source.html">TBlockableAtomicQuasiQueue.h</a></li>
<li>Source/Utility/Concurrent/<a class="el" href="_t_blockable_atomic_quasi_queue_8ipp_source.html">TBlockableAtomicQuasiQueue.ipp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="classph_1_1_t_blockable_atomic_quasi_queue.html">TBlockableAtomicQuasiQueue</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
