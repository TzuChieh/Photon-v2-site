<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon Engine: ph::ByteBufferInputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Photon Engine<span id="projectnumber">&#160;2.0.0-beta</span>
   </div>
   <div id="projectbrief">A physically based renderer.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classph_1_1_byte_buffer_input_stream.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classph_1_1_byte_buffer_input_stream-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ph::ByteBufferInputStream Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>An in-memory byte stream designed for I/O performance.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_byte_buffer_input_stream_8h_source.html">ByteBufferInputStream.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for ph::ByteBufferInputStream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classph_1_1_byte_buffer_input_stream.png" usemap="#ph::ByteBufferInputStream_map" alt=""/>
  <map id="ph::ByteBufferInputStream_map" name="ph::ByteBufferInputStream_map">
<area href="classph_1_1_i_input_stream.html" alt="ph::IInputStream" shape="rect" coords="0,56,158,80"/>
<area href="classph_1_1_i_data_stream.html" alt="ph::IDataStream" shape="rect" coords="0,0,158,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5fcaef8189f0150a872f5c0fe8f26826" id="r_a5fcaef8189f0150a872f5c0fe8f26826"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fcaef8189f0150a872f5c0fe8f26826">ByteBufferInputStream</a> ()</td></tr>
<tr class="separator:a5fcaef8189f0150a872f5c0fe8f26826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24d9335d36828468de94835af5dbfe9f" id="r_a24d9335d36828468de94835af5dbfe9f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a24d9335d36828468de94835af5dbfe9f">ByteBufferInputStream</a> (const std::byte *srcByteBuffer, std::size_t numBytes)</td></tr>
<tr class="separator:a24d9335d36828468de94835af5dbfe9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae594edffbb347492c78ce1d4fbfad929" id="r_ae594edffbb347492c78ce1d4fbfad929"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae594edffbb347492c78ce1d4fbfad929">ByteBufferInputStream</a> (const char *srcCharBuffer, std::size_t numChars)</td></tr>
<tr class="separator:ae594edffbb347492c78ce1d4fbfad929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd969dbe5661f65a7bbe4c6a324d344" id="r_accd969dbe5661f65a7bbe4c6a324d344"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#accd969dbe5661f65a7bbe4c6a324d344">ByteBufferInputStream</a> (const unsigned char *srcUCharBuffer, std::size_t numUChars)</td></tr>
<tr class="separator:accd969dbe5661f65a7bbe4c6a324d344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff2c79ebda3e694a46493f170ed8be3" id="r_a3ff2c79ebda3e694a46493f170ed8be3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ff2c79ebda3e694a46493f170ed8be3">ByteBufferInputStream</a> (std::size_t numBytes)</td></tr>
<tr class="separator:a3ff2c79ebda3e694a46493f170ed8be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81203ec4723689526ee4e6f76cf9b5f1" id="r_a81203ec4723689526ee4e6f76cf9b5f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81203ec4723689526ee4e6f76cf9b5f1">ByteBufferInputStream</a> (<a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a81203ec4723689526ee4e6f76cf9b5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3b1c48b2ff207a2ddfd877c8373d7e" id="r_aaa3b1c48b2ff207a2ddfd877c8373d7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa3b1c48b2ff207a2ddfd877c8373d7e">read</a> (std::size_t numBytes, std::byte *out_bytes) override</td></tr>
<tr class="memdesc:aaa3b1c48b2ff207a2ddfd877c8373d7e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read specific number of raw bytes in one go. The method does not return before finishing the reading process.  <br /></td></tr>
<tr class="separator:aaa3b1c48b2ff207a2ddfd877c8373d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4492e8813fca4621a0652a081597ac34" id="r_a4492e8813fca4621a0652a081597ac34"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4492e8813fca4621a0652a081597ac34">readString</a> (std::string *out_string, char delimiter) override</td></tr>
<tr class="memdesc:a4492e8813fca4621a0652a081597ac34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a string in one go. Note the EOF is also considered a delimiter (the final one).  <br /></td></tr>
<tr class="separator:a4492e8813fca4621a0652a081597ac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46844aec5022752b7fca2eee8374bb54" id="r_a46844aec5022752b7fca2eee8374bb54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a46844aec5022752b7fca2eee8374bb54">seekGet</a> (std::size_t pos) override</td></tr>
<tr class="memdesc:a46844aec5022752b7fca2eee8374bb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the input position of the stream. The unit of the position is defined by the implementation.  <br /></td></tr>
<tr class="separator:a46844aec5022752b7fca2eee8374bb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a158c89d7e05dc9a328dbae3adfce794d" id="r_a158c89d7e05dc9a328dbae3adfce794d"><td class="memItemLeft" align="right" valign="top">std::optional&lt; std::size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a158c89d7e05dc9a328dbae3adfce794d">tellGet</a> () override</td></tr>
<tr class="memdesc:a158c89d7e05dc9a328dbae3adfce794d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current input position of the stream. The unit of the position is defined by the implementation.  <br /></td></tr>
<tr class="separator:a158c89d7e05dc9a328dbae3adfce794d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1094704e4ca8947d08c828003122dfb4" id="r_a1094704e4ca8947d08c828003122dfb4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1094704e4ca8947d08c828003122dfb4">operator bool</a> () const override</td></tr>
<tr class="separator:a1094704e4ca8947d08c828003122dfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11b8290552e2c2da98fcb9e579ba3ad" id="r_ad11b8290552e2c2da98fcb9e579ba3ad"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad11b8290552e2c2da98fcb9e579ba3ad">readSome</a> (std::size_t numBytes, std::byte *out_bytes) override</td></tr>
<tr class="memdesc:ad11b8290552e2c2da98fcb9e579ba3ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read some data in the form of raw bytes. The method may return before finish reading all bytes. In such case, the method returns how many bytes were actually read.  <br /></td></tr>
<tr class="separator:ad11b8290552e2c2da98fcb9e579ba3ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb75c64dd14f87612fbae375db94ce4f" id="r_afb75c64dd14f87612fbae375db94ce4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afb75c64dd14f87612fbae375db94ce4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afb75c64dd14f87612fbae375db94ce4f">readData</a> (T *out_data)</td></tr>
<tr class="separator:afb75c64dd14f87612fbae375db94ce4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605f9c257b4aa87ce2025b075853c66a" id="r_a605f9c257b4aa87ce2025b075853c66a"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a605f9c257b4aa87ce2025b075853c66a">numBufferBytes</a> () const</td></tr>
<tr class="memdesc:a605f9c257b4aa87ce2025b075853c66a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the size of the underlying byte buffer.  <br /></td></tr>
<tr class="separator:a605f9c257b4aa87ce2025b075853c66a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc4b8d1b73079606968bf29a9078b6b" id="r_a7fc4b8d1b73079606968bf29a9078b6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7fc4b8d1b73079606968bf29a9078b6b">canRead</a> (std::size_t numBytes) const</td></tr>
<tr class="memdesc:a7fc4b8d1b73079606968bf29a9078b6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we can read <code>numBytes</code> of bytes from the stream.  <br /></td></tr>
<tr class="separator:a7fc4b8d1b73079606968bf29a9078b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd6c22e7bd88058de6ca0b0f325acc18" id="r_afd6c22e7bd88058de6ca0b0f325acc18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afd6c22e7bd88058de6ca0b0f325acc18">canRead</a> () const</td></tr>
<tr class="memdesc:afd6c22e7bd88058de6ca0b0f325acc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether we can read any number (non-zero) of bytes from the stream.  <br /></td></tr>
<tr class="separator:afd6c22e7bd88058de6ca0b0f325acc18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a922af9c21d205acc26390431ec522847" id="r_a922af9c21d205acc26390431ec522847"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a922af9c21d205acc26390431ec522847">operator=</a> (<a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:a922af9c21d205acc26390431ec522847"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a09f33d06b0b1010ac0409efd6d613fe1" id="r_a09f33d06b0b1010ac0409efd6d613fe1"><td class="memItemLeft" align="right" valign="top">std::byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a09f33d06b0b1010ac0409efd6d613fe1">byteBuffer</a> ()</td></tr>
<tr class="memdesc:a09f33d06b0b1010ac0409efd6d613fe1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Direct access to the underlying byte buffer.  <br /></td></tr>
<tr class="separator:a09f33d06b0b1010ac0409efd6d613fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad025d9770455e449bee467e1f61abe22" id="r_ad025d9770455e449bee467e1f61abe22"><td class="memItemLeft" align="right" valign="top">const std::byte *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad025d9770455e449bee467e1f61abe22">byteBuffer</a> () const</td></tr>
<tr class="separator:ad025d9770455e449bee467e1f61abe22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Aliased buffer accessors.</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Helpers for accessing the underlying buffer using an aliased type (char or unsigned char). Note that the aliasing does not violate strict aliasing rules as it is specifically allowed by the standard to use char and unsigned char to alias any other types (in our case it is std::byte). </p>
</div></td></tr>
<tr class="memitem:a3a68e0f7bc352888ebe42c4ad0f96521" id="r_a3a68e0f7bc352888ebe42c4ad0f96521"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3a68e0f7bc352888ebe42c4ad0f96521">charBuffer</a> ()</td></tr>
<tr class="separator:a3a68e0f7bc352888ebe42c4ad0f96521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a945a57493f317b7818e4a3e29d439f76" id="r_a945a57493f317b7818e4a3e29d439f76"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a945a57493f317b7818e4a3e29d439f76">charBuffer</a> () const</td></tr>
<tr class="separator:a945a57493f317b7818e4a3e29d439f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac5f174ee25c50910c8b4c2267ed05d3" id="r_aac5f174ee25c50910c8b4c2267ed05d3"><td class="memItemLeft" align="right" valign="top">unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac5f174ee25c50910c8b4c2267ed05d3">ucharBuffer</a> ()</td></tr>
<tr class="separator:aac5f174ee25c50910c8b4c2267ed05d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6750705bc3c393aef0a8ada6a68b740c" id="r_a6750705bc3c393aef0a8ada6a68b740c"><td class="memItemLeft" align="right" valign="top">const unsigned char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6750705bc3c393aef0a8ada6a68b740c">ucharBuffer</a> () const</td></tr>
<tr class="separator:a6750705bc3c393aef0a8ada6a68b740c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classph_1_1_i_input_stream"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classph_1_1_i_input_stream')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classph_1_1_i_input_stream.html">ph::IInputStream</a></td></tr>
<tr class="memitem:a4273ab96ff0f4cbcd0f9863c1fee5a11 inherit pub_methods_classph_1_1_i_input_stream" id="r_a4273ab96ff0f4cbcd0f9863c1fee5a11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_i_input_stream.html#a4273ab96ff0f4cbcd0f9863c1fee5a11">readLine</a> (std::string *out_string)</td></tr>
<tr class="memdesc:a4273ab96ff0f4cbcd0f9863c1fee5a11 inherit pub_methods_classph_1_1_i_input_stream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a line. Equivalent to calling <a class="el" href="classph_1_1_i_input_stream.html#ad8a53daafc7dcabdc7da7989f1fc429d" title="Read a string in one go. Note the EOF is also considered a delimiter (the final one).">readString(std::string*, char)</a> with '<br  />
' as the delimiter.  <br /></td></tr>
<tr class="separator:a4273ab96ff0f4cbcd0f9863c1fee5a11 inherit pub_methods_classph_1_1_i_input_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classph_1_1_i_data_stream"><td colspan="2" onclick="javascript:dynsection.toggleInherit('pub_methods_classph_1_1_i_data_stream')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classph_1_1_i_data_stream.html">ph::IDataStream</a></td></tr>
<tr class="memitem:aaae26b4cc468668cd571d8e2d8bd16ae inherit pub_methods_classph_1_1_i_data_stream" id="r_aaae26b4cc468668cd571d8e2d8bd16ae"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_i_data_stream.html#aaae26b4cc468668cd571d8e2d8bd16ae">~IDataStream</a> ()=default</td></tr>
<tr class="separator:aaae26b4cc468668cd571d8e2d8bd16ae inherit pub_methods_classph_1_1_i_data_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22c33c2e5d790bce6bf3453bf0240218 inherit pub_methods_classph_1_1_i_data_stream" id="r_a22c33c2e5d790bce6bf3453bf0240218"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classph_1_1_i_data_stream.html#a22c33c2e5d790bce6bf3453bf0240218">acquireName</a> () const</td></tr>
<tr class="memdesc:a22c33c2e5d790bce6bf3453bf0240218 inherit pub_methods_classph_1_1_i_data_stream"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access to the stream's name. This method is not meant to be used in a high performance context, unless otherwise stated by the overridder. Stream name is not always available.  <br /></td></tr>
<tr class="separator:a22c33c2e5d790bce6bf3453bf0240218 inherit pub_methods_classph_1_1_i_data_stream"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An in-memory byte stream designed for I/O performance. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5fcaef8189f0150a872f5c0fe8f26826" name="a5fcaef8189f0150a872f5c0fe8f26826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fcaef8189f0150a872f5c0fe8f26826">&#9670;&#160;</a></span>ByteBufferInputStream() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24d9335d36828468de94835af5dbfe9f" name="a24d9335d36828468de94835af5dbfe9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d9335d36828468de94835af5dbfe9f">&#9670;&#160;</a></span>ByteBufferInputStream() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">const std::byte *</td>          <td class="paramname"><span class="paramname"><em>srcByteBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae594edffbb347492c78ce1d4fbfad929" name="ae594edffbb347492c78ce1d4fbfad929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae594edffbb347492c78ce1d4fbfad929">&#9670;&#160;</a></span>ByteBufferInputStream() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>srcCharBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numChars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="accd969dbe5661f65a7bbe4c6a324d344" name="accd969dbe5661f65a7bbe4c6a324d344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd969dbe5661f65a7bbe4c6a324d344">&#9670;&#160;</a></span>ByteBufferInputStream() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *</td>          <td class="paramname"><span class="paramname"><em>srcUCharBuffer</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numUChars</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ff2c79ebda3e694a46493f170ed8be3" name="a3ff2c79ebda3e694a46493f170ed8be3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff2c79ebda3e694a46493f170ed8be3">&#9670;&#160;</a></span>ByteBufferInputStream() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81203ec4723689526ee4e6f76cf9b5f1" name="a81203ec4723689526ee4e6f76cf9b5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81203ec4723689526ee4e6f76cf9b5f1">&#9670;&#160;</a></span>ByteBufferInputStream() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::ByteBufferInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>other</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a09f33d06b0b1010ac0409efd6d613fe1" name="a09f33d06b0b1010ac0409efd6d613fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f33d06b0b1010ac0409efd6d613fe1">&#9670;&#160;</a></span>byteBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::byte * ph::ByteBufferInputStream::byteBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Direct access to the underlying byte buffer. </p>

</div>
</div>
<a id="ad025d9770455e449bee467e1f61abe22" name="ad025d9770455e449bee467e1f61abe22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad025d9770455e449bee467e1f61abe22">&#9670;&#160;</a></span>byteBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::byte * ph::ByteBufferInputStream::byteBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd6c22e7bd88058de6ca0b0f325acc18" name="afd6c22e7bd88058de6ca0b0f325acc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd6c22e7bd88058de6ca0b0f325acc18">&#9670;&#160;</a></span>canRead() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ph::ByteBufferInputStream::canRead </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we can read any number (non-zero) of bytes from the stream. </p>

</div>
</div>
<a id="a7fc4b8d1b73079606968bf29a9078b6b" name="a7fc4b8d1b73079606968bf29a9078b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc4b8d1b73079606968bf29a9078b6b">&#9670;&#160;</a></span>canRead() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ph::ByteBufferInputStream::canRead </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether we can read <code>numBytes</code> of bytes from the stream. </p>

</div>
</div>
<a id="a3a68e0f7bc352888ebe42c4ad0f96521" name="a3a68e0f7bc352888ebe42c4ad0f96521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a68e0f7bc352888ebe42c4ad0f96521">&#9670;&#160;</a></span>charBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * ph::ByteBufferInputStream::charBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a945a57493f317b7818e4a3e29d439f76" name="a945a57493f317b7818e4a3e29d439f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a945a57493f317b7818e4a3e29d439f76">&#9670;&#160;</a></span>charBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * ph::ByteBufferInputStream::charBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a605f9c257b4aa87ce2025b075853c66a" name="a605f9c257b4aa87ce2025b075853c66a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a605f9c257b4aa87ce2025b075853c66a">&#9670;&#160;</a></span>numBufferBytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ph::ByteBufferInputStream::numBufferBytes </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the size of the underlying byte buffer. </p>

</div>
</div>
<a id="a1094704e4ca8947d08c828003122dfb4" name="a1094704e4ca8947d08c828003122dfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1094704e4ca8947d08c828003122dfb4">&#9670;&#160;</a></span>operator bool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ph::ByteBufferInputStream::operator bool </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>Whether the stream is good for read. </dd></dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#ac3c06f5cef30fa9bc93601420076db10">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a922af9c21d205acc26390431ec522847" name="a922af9c21d205acc26390431ec522847"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a922af9c21d205acc26390431ec522847">&#9670;&#160;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp; ph::ByteBufferInputStream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a> &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>rhs</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa3b1c48b2ff207a2ddfd877c8373d7e" name="aaa3b1c48b2ff207a2ddfd877c8373d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3b1c48b2ff207a2ddfd877c8373d7e">&#9670;&#160;</a></span>read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::read </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *</td>          <td class="paramname"><span class="paramname"><em>out_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read specific number of raw bytes in one go. The method does not return before finishing the reading process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numBytes</td><td>Number of bytes to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_bytes</td><td>The read bytes. Must contain storage for at least <code>numBytes</code> bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>If the read operation failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#a52d50a00cce8bf8db08b0609e6218382">ph::IInputStream</a>.</p>

</div>
</div>
<a id="afb75c64dd14f87612fbae375db94ce4f" name="afb75c64dd14f87612fbae375db94ce4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb75c64dd14f87612fbae375db94ce4f">&#9670;&#160;</a></span>readData()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::readData </td>
          <td>(</td>
          <td class="paramtype">T *</td>          <td class="paramname"><span class="paramname"><em>out_data</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad11b8290552e2c2da98fcb9e579ba3ad" name="ad11b8290552e2c2da98fcb9e579ba3ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11b8290552e2c2da98fcb9e579ba3ad">&#9670;&#160;</a></span>readSome()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t ph::ByteBufferInputStream::readSome </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>numBytes</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::byte *</td>          <td class="paramname"><span class="paramname"><em>out_bytes</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read some data in the form of raw bytes. The method may return before finish reading all bytes. In such case, the method returns how many bytes were actually read. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">numBytes</td><td>Maximum number of bytes to read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">out_bytes</td><td>The read bytes. Must contain storage for at least <code>numBytes</code> bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>How many bytes were actually read. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>If the read operation failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented from <a class="el" href="classph_1_1_i_input_stream.html#ae2443ee3348bfd6dc361e1eeed893a32">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a4492e8813fca4621a0652a081597ac34" name="a4492e8813fca4621a0652a081597ac34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4492e8813fca4621a0652a081597ac34">&#9670;&#160;</a></span>readString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::readString </td>
          <td>(</td>
          <td class="paramtype">std::string *</td>          <td class="paramname"><span class="paramname"><em>out_string</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char</td>          <td class="paramname"><span class="paramname"><em>delimiter</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read a string in one go. Note the EOF is also considered a delimiter (the final one). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">out_string</td><td>The read string. Does not include the <code>delimiter</code>. </td></tr>
    <tr><td class="paramname">delimiter</td><td>The character that denotes the ending of a line. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>If the read operation failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#ad8a53daafc7dcabdc7da7989f1fc429d">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a46844aec5022752b7fca2eee8374bb54" name="a46844aec5022752b7fca2eee8374bb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46844aec5022752b7fca2eee8374bb54">&#9670;&#160;</a></span>seekGet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ph::ByteBufferInputStream::seekGet </td>
          <td>(</td>
          <td class="paramtype">std::size_t</td>          <td class="paramname"><span class="paramname"><em>pos</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the input position of the stream. The unit of the position is defined by the implementation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The position to set to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">IOException</td><td>If the seeking process failed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#a4bc65760be9331abdbbd97a8e3539491">ph::IInputStream</a>.</p>

</div>
</div>
<a id="a158c89d7e05dc9a328dbae3adfce794d" name="a158c89d7e05dc9a328dbae3adfce794d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a158c89d7e05dc9a328dbae3adfce794d">&#9670;&#160;</a></span>tellGet()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::optional&lt; std::size_t &gt; ph::ByteBufferInputStream::tellGet </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the current input position of the stream. The unit of the position is defined by the implementation. </p>
<dl class="section return"><dt>Returns</dt><dd>Current input position. Empty if the position is unavailable. </dd></dl>

<p>Implements <a class="el" href="classph_1_1_i_input_stream.html#a05a872bb07dbe846a0c680e99fd3793d">ph::IInputStream</a>.</p>

</div>
</div>
<a id="aac5f174ee25c50910c8b4c2267ed05d3" name="aac5f174ee25c50910c8b4c2267ed05d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac5f174ee25c50910c8b4c2267ed05d3">&#9670;&#160;</a></span>ucharBuffer() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned char * ph::ByteBufferInputStream::ucharBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6750705bc3c393aef0a8ada6a68b740c" name="a6750705bc3c393aef0a8ada6a68b740c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6750705bc3c393aef0a8ada6a68b740c">&#9670;&#160;</a></span>ucharBuffer() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned char * ph::ByteBufferInputStream::ucharBuffer </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/DataIO/Stream/<a class="el" href="_byte_buffer_input_stream_8h_source.html">ByteBufferInputStream.h</a></li>
<li>Source/DataIO/Stream/<a class="el" href="_byte_buffer_input_stream_8cpp.html">ByteBufferInputStream.cpp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="classph_1_1_byte_buffer_input_stream.html">ByteBufferInputStream</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
