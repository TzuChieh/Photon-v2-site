<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" class="dark-mode">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon Engine: ph::TSPSCExecutor&lt; Work &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<!-- Add a link to project GitHub by https://tholman.com/github-corners/ -->
<a href="https://github.com/TzuChieh/Photon-v2" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#FD6C6C; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a><style>.github-corner:hover .octo-arm{animation:octocat-wave 560ms ease-in-out}@keyframes octocat-wave{0%,100%{transform:rotate(0)}20%,60%{transform:rotate(-25deg)}40%,80%{transform:rotate(10deg)}}@media (max-width:500px){.github-corner:hover .octo-arm{animation:none}.github-corner .octo-arm{animation:octocat-wave 560ms ease-in-out}}</style>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Photon Engine<span id="projectnumber">&#160;2.0.0-beta</span>
   </div>
   <div id="projectbrief">A physically based renderer.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('classph_1_1_t_s_p_s_c_executor.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classph_1_1_t_s_p_s_c_executor-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">ph::TSPSCExecutor&lt; Work &gt; Class Template Reference<span class="mlabels"><span class="mlabel">final</span></span></div></div>
</div><!--header-->
<div class="contents">

<p>A single-producer, single-consumer worker thread. Ctor and dtor are not thread safe. Most of the methods are either producer thread only, or thread-safe. <code><a class="el" href="#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a></code> must be called before adding work since it also serves as a mean to determine the producer thread. Setters for function callbacks can only be called before <code><a class="el" href="#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a></code>. Note that if work processor is not set from ctor, <code><a class="el" href="#aff408fe833f82bb136083d0e62ff8592" title="Setters for callbacks. Callbacks will execute on consumer thread.">setWorkProcessor()</a></code> must be called with a valid processor function.  
 <a href="#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="_t_s_p_s_c_executor_8h_source.html">TSPSCExecutor.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9f6b5ce0addb84a3de6294984c9612a3" id="r_a9f6b5ce0addb84a3de6294984c9612a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9f6b5ce0addb84a3de6294984c9612a3">TSPSCExecutor</a> ()</td></tr>
<tr class="memdesc:a9f6b5ce0addb84a3de6294984c9612a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an executor waiting for new work.  <br /></td></tr>
<tr class="separator:a9f6b5ce0addb84a3de6294984c9612a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dfdf73fc1054ad47c06b9370768b58f" id="r_a6dfdf73fc1054ad47c06b9370768b58f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6dfdf73fc1054ad47c06b9370768b58f">TSPSCExecutor</a> (std::function&lt; void(const Work &amp;work)&gt; workProcessor)</td></tr>
<tr class="memdesc:a6dfdf73fc1054ad47c06b9370768b58f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an executor waiting for new work.  <br /></td></tr>
<tr class="separator:a6dfdf73fc1054ad47c06b9370768b58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98a11651bfe5596cb1acb4d5125c45fb" id="r_a98a11651bfe5596cb1acb4d5125c45fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a98a11651bfe5596cb1acb4d5125c45fb">~TSPSCExecutor</a> ()</td></tr>
<tr class="memdesc:a98a11651bfe5596cb1acb4d5125c45fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Terminate the execution. Wait for any ongoing work to finish.  <br /></td></tr>
<tr class="separator:a98a11651bfe5596cb1acb4d5125c45fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4416821710b9c3c01b9798376a9f4e" id="r_a0d4416821710b9c3c01b9798376a9f4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d4416821710b9c3c01b9798376a9f4e">start</a> ()</td></tr>
<tr class="memdesc:a0d4416821710b9c3c01b9798376a9f4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start the execution of the consumer (worker thread). Whichever thread calls this method will be the producer thread. Can only be called once in the lifetime of the executor.  <br /></td></tr>
<tr class="separator:a0d4416821710b9c3c01b9798376a9f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348023aebd44b96af2d54e6aacda79a0" id="r_a348023aebd44b96af2d54e6aacda79a0"><td class="memTemplParams" colspan="2">template&lt;typename DeducedWork &gt; </td></tr>
<tr class="memitem:a348023aebd44b96af2d54e6aacda79a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a348023aebd44b96af2d54e6aacda79a0">addWork</a> (DeducedWork &amp;&amp;work)</td></tr>
<tr class="separator:a348023aebd44b96af2d54e6aacda79a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b1bd75567ccb5adcd30bdd592b42ce" id="r_a75b1bd75567ccb5adcd30bdd592b42ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a75b1bd75567ccb5adcd30bdd592b42ce">waitAllWorks</a> ()</td></tr>
<tr class="memdesc:a75b1bd75567ccb5adcd30bdd592b42ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for all queued works to finish. Memory effects on consumer thread are made visible to the producer thread.  <br /></td></tr>
<tr class="separator:a75b1bd75567ccb5adcd30bdd592b42ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bee5c6bbc09397af7f73ef55969c93" id="r_a52bee5c6bbc09397af7f73ef55969c93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a52bee5c6bbc09397af7f73ef55969c93">requestTermination</a> ()</td></tr>
<tr class="memdesc:a52bee5c6bbc09397af7f73ef55969c93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the executor. Executor will stop processing any work as soon as possible. Any work that is already being processed will still complete. No further write operations should be performed after requesting termination. Requesting termination multiple times has the same effect.  <br /></td></tr>
<tr class="separator:a52bee5c6bbc09397af7f73ef55969c93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace6ac9244a6753e4a2da159fabd10d8d" id="r_ace6ac9244a6753e4a2da159fabd10d8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace6ac9244a6753e4a2da159fabd10d8d">waitForTermination</a> ()</td></tr>
<tr class="memdesc:ace6ac9244a6753e4a2da159fabd10d8d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wait for the executor to stop. All operations on the consumer thread will be done after this call returns. Memory effects on consumer thread are made visible to the producer thread. Cannot be called on consumer thread as this can lead to deadlock.  <br /></td></tr>
<tr class="separator:ace6ac9244a6753e4a2da159fabd10d8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd7b547217281c83d117359584375b1" id="r_a7dd7b547217281c83d117359584375b1"><td class="memItemLeft" align="right" valign="top">std::thread::id&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7dd7b547217281c83d117359584375b1">getId</a> () const</td></tr>
<tr class="memdesc:a7dd7b547217281c83d117359584375b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get ID of the underlying thread.  <br /></td></tr>
<tr class="separator:a7dd7b547217281c83d117359584375b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac550b3718b38d56f5684e1ea546ee7d2" id="r_ac550b3718b38d56f5684e1ea546ee7d2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac550b3718b38d56f5684e1ea546ee7d2">hasStarted</a> () const</td></tr>
<tr class="memdesc:ac550b3718b38d56f5684e1ea546ee7d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the executor has started processing works.  <br /></td></tr>
<tr class="separator:ac550b3718b38d56f5684e1ea546ee7d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:aff408fe833f82bb136083d0e62ff8592" id="r_aff408fe833f82bb136083d0e62ff8592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff408fe833f82bb136083d0e62ff8592">setWorkProcessor</a> (std::function&lt; void(const Work &amp;work)&gt; workProcessor)</td></tr>
<tr class="memdesc:aff408fe833f82bb136083d0e62ff8592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Setters for callbacks. Callbacks will execute on consumer thread.  <br /></td></tr>
<tr class="separator:aff408fe833f82bb136083d0e62ff8592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3352d75b6451c17a0093f81900597d3f" id="r_a3352d75b6451c17a0093f81900597d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3352d75b6451c17a0093f81900597d3f">setOnConsumerStart</a> (std::function&lt; void(void)&gt; onConsumerStart)</td></tr>
<tr class="separator:a3352d75b6451c17a0093f81900597d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1ccd9b88d8123367b8a194ee2a0d79d" id="r_ae1ccd9b88d8123367b8a194ee2a0d79d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae1ccd9b88d8123367b8a194ee2a0d79d">setOnConsumerTerminate</a> (std::function&lt; void(void)&gt; onConsumerTerminate)</td></tr>
<tr class="separator:ae1ccd9b88d8123367b8a194ee2a0d79d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><div class="compoundTemplParams">template&lt;typename Work&gt;<br />
class ph::TSPSCExecutor&lt; Work &gt;</div><p>A single-producer, single-consumer worker thread. Ctor and dtor are not thread safe. Most of the methods are either producer thread only, or thread-safe. <code><a class="el" href="#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a></code> must be called before adding work since it also serves as a mean to determine the producer thread. Setters for function callbacks can only be called before <code><a class="el" href="#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a></code>. Note that if work processor is not set from ctor, <code><a class="el" href="#aff408fe833f82bb136083d0e62ff8592" title="Setters for callbacks. Callbacks will execute on consumer thread.">setWorkProcessor()</a></code> must be called with a valid processor function. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Work</td><td>Type of the work to be processed. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9f6b5ce0addb84a3de6294984c9612a3" name="a9f6b5ce0addb84a3de6294984c9612a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6b5ce0addb84a3de6294984c9612a3">&#9670;&#160;</a></span>TSPSCExecutor() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::TSPSCExecutor </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an executor waiting for new work. </p>

</div>
</div>
<a id="a6dfdf73fc1054ad47c06b9370768b58f" name="a6dfdf73fc1054ad47c06b9370768b58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dfdf73fc1054ad47c06b9370768b58f">&#9670;&#160;</a></span>TSPSCExecutor() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::TSPSCExecutor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const Work &amp;work)&gt;</td>          <td class="paramname"><span class="paramname"><em>workProcessor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an executor waiting for new work. </p>

</div>
</div>
<a id="a98a11651bfe5596cb1acb4d5125c45fb" name="a98a11651bfe5596cb1acb4d5125c45fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98a11651bfe5596cb1acb4d5125c45fb">&#9670;&#160;</a></span>~TSPSCExecutor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::~<a class="el" href="classph_1_1_t_s_p_s_c_executor.html">TSPSCExecutor</a> </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Terminate the execution. Wait for any ongoing work to finish. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a348023aebd44b96af2d54e6aacda79a0" name="a348023aebd44b96af2d54e6aacda79a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348023aebd44b96af2d54e6aacda79a0">&#9670;&#160;</a></span>addWork()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<div class="memtemplate">
template&lt;typename DeducedWork &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::addWork </td>
          <td>(</td>
          <td class="paramtype">DeducedWork &amp;&amp;</td>          <td class="paramname"><span class="paramname"><em>work</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Basic aquire-release semantics are guaranteed. This ensures that all the effects of work done by the producer thread before it enqueues a work will be visible on the consumer thread after it dequeues that work. </p><dl class="section note"><dt>Note</dt><dd>Producer thread only. </dd></dl>

</div>
</div>
<a id="a7dd7b547217281c83d117359584375b1" name="a7dd7b547217281c83d117359584375b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dd7b547217281c83d117359584375b1">&#9670;&#160;</a></span>getId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::thread::id <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::getId </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get ID of the underlying thread. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<a id="ac550b3718b38d56f5684e1ea546ee7d2" name="ac550b3718b38d56f5684e1ea546ee7d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac550b3718b38d56f5684e1ea546ee7d2">&#9670;&#160;</a></span>hasStarted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::hasStarted </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the executor has started processing works. </p>
<dl class="section note"><dt>Note</dt><dd>Producer and consumer thread only. </dd></dl>

</div>
</div>
<a id="a52bee5c6bbc09397af7f73ef55969c93" name="a52bee5c6bbc09397af7f73ef55969c93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bee5c6bbc09397af7f73ef55969c93">&#9670;&#160;</a></span>requestTermination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::requestTermination </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stop the executor. Executor will stop processing any work as soon as possible. Any work that is already being processed will still complete. No further write operations should be performed after requesting termination. Requesting termination multiple times has the same effect. </p>
<dl class="section note"><dt>Note</dt><dd>Producer thread only. </dd></dl>

</div>
</div>
<a id="a3352d75b6451c17a0093f81900597d3f" name="a3352d75b6451c17a0093f81900597d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3352d75b6451c17a0093f81900597d3f">&#9670;&#160;</a></span>setOnConsumerStart()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::setOnConsumerStart </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt;</td>          <td class="paramname"><span class="paramname"><em>onConsumerStart</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1ccd9b88d8123367b8a194ee2a0d79d" name="ae1ccd9b88d8123367b8a194ee2a0d79d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1ccd9b88d8123367b8a194ee2a0d79d">&#9670;&#160;</a></span>setOnConsumerTerminate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::setOnConsumerTerminate </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(void)&gt;</td>          <td class="paramname"><span class="paramname"><em>onConsumerTerminate</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aff408fe833f82bb136083d0e62ff8592" name="aff408fe833f82bb136083d0e62ff8592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff408fe833f82bb136083d0e62ff8592">&#9670;&#160;</a></span>setWorkProcessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::setWorkProcessor </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const Work &amp;work)&gt;</td>          <td class="paramname"><span class="paramname"><em>workProcessor</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Setters for callbacks. Callbacks will execute on consumer thread. </p>
<dl class="section note"><dt>Note</dt><dd>Can only be set before <a class="el" href="#a0d4416821710b9c3c01b9798376a9f4e" title="Start the execution of the consumer (worker thread). Whichever thread calls this method will be the p...">start()</a>. </dd></dl>

</div>
</div>
<a id="a0d4416821710b9c3c01b9798376a9f4e" name="a0d4416821710b9c3c01b9798376a9f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4416821710b9c3c01b9798376a9f4e">&#9670;&#160;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::start </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start the execution of the consumer (worker thread). Whichever thread calls this method will be the producer thread. Can only be called once in the lifetime of the executor. </p>
<dl class="section note"><dt>Note</dt><dd>The thread that calls this method is considered the producer thread. </dd></dl>

</div>
</div>
<a id="a75b1bd75567ccb5adcd30bdd592b42ce" name="a75b1bd75567ccb5adcd30bdd592b42ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b1bd75567ccb5adcd30bdd592b42ce">&#9670;&#160;</a></span>waitAllWorks()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::waitAllWorks </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for all queued works to finish. Memory effects on consumer thread are made visible to the producer thread. </p>
<dl class="section note"><dt>Note</dt><dd>Producer thread only. </dd></dl>

</div>
</div>
<a id="ace6ac9244a6753e4a2da159fabd10d8d" name="ace6ac9244a6753e4a2da159fabd10d8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace6ac9244a6753e4a2da159fabd10d8d">&#9670;&#160;</a></span>waitForTermination()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Work &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classph_1_1_t_s_p_s_c_executor.html">ph::TSPSCExecutor</a>&lt; Work &gt;::waitForTermination </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Wait for the executor to stop. All operations on the consumer thread will be done after this call returns. Memory effects on consumer thread are made visible to the producer thread. Cannot be called on consumer thread as this can lead to deadlock. </p>
<dl class="section note"><dt>Note</dt><dd>Thread-safe. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>Source/Utility/Concurrent/<a class="el" href="_t_s_p_s_c_executor_8h_source.html">TSPSCExecutor.h</a></li>
<li>Source/Utility/Concurrent/<a class="el" href="_t_s_p_s_c_executor_8ipp_source.html">TSPSCExecutor.ipp</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceph.html">ph</a></li><li class="navelem"><a class="el" href="classph_1_1_t_s_p_s_c_executor.html">TSPSCExecutor</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
