<!-- HTML header for doxygen 1.11.0-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Photon: Feature Overview</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
<link href="custom.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="doxygen-awesome-interactive-toc.js"></script>
<script type="text/javascript">
    DoxygenAwesomeInteractiveToc.init()
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Photon<span id="projectnumber">&#160;2.0.0-beta</span>
   </div>
   <div id="projectbrief">A physically based renderer.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('main_feature_overview.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Feature Overview</div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#autotoc_md18">Visualizer</a><ul><li class="level2"><a href="#bvpt">Unidirectional Path Tracing</a></li>
<li class="level2"><a href="#bneept">Unidirectional Path Tracing with NEE</a></li>
<li class="level2"><a href="#vpm">Vanilla Photon Mapping</a></li>
<li class="level2"><a href="#ppm">Progressive Photon Mapping</a></li>
<li class="level2"><a href="#sppm">Stochastic Progressive Photon Mapping</a></li>
<li class="level2"><a href="#pppm">Probabilistic Progressive Photon Mapping</a></li>
<li class="level2"><a href="#autotoc_md19">Scheduler</a></li>
</ul>
</li>
<li class="level1"><a href="#observer">Observer</a><ul><li class="level2"><a href="#pinhole">Pinhole Camera</a></li>
<li class="level2"><a href="#thinlens">Thin Lens Camera</a></li>
<li class="level2"><a href="#autotoc_md20">Environment Camera</a></li>
<li class="level2"><a href="#autotoc_md21">Energy Measurement</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md22">Image</a><ul><li class="level2"><a href="#autotoc_md23">Texture</a></li>
<li class="level2"><a href="#autotoc_md24">Film</a></li>
<li class="level2"><a href="#autotoc_md25">Filtering</a></li>
<li class="level2"><a href="#autotoc_md26">Tone-mapping</a></li>
<li class="level2"><a href="#autotoc_md27">Reading and Writing</a></li>
<li class="level2"><a href="#autotoc_md28">Merging</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md29">Material</a><ul><li class="level2"><a href="#autotoc_md30">Surface Behavior</a></li>
<li class="level2"><a href="#autotoc_md31">Volume Behavior</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md32">Geometry</a><ul><li class="level2"><a href="#autotoc_md33">Intersectable and Primitive</a></li>
<li class="level2"><a href="#autotoc_md34">Basic Shapes</a></li>
<li class="level2"><a href="#autotoc_md35">Advanced Shapes</a></li>
<li class="level2"><a href="#autotoc_md36">Acceleration Structure</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md37">Light</a><ul><li class="level2"><a href="#autotoc_md38">Emitter</a></li>
</ul>
</li>
<li class="level1"><a href="#autotoc_md39">Sample Source</a><ul><li class="level2"><a href="#autotoc_md40">Sample Generator</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p><a class="anchor" id="md__documentation_2feature__overview"></a></p>
<p>A quick overview of the features supported by Photon. Similar to <a class="el" href="main_project_structure.html#md__documentation_2project__structure">Project Structure</a>, this page can also serve as a handy reference for you to find the documentation or source code that you need.</p>
<h1><a class="anchor" id="autotoc_md18"></a>
Visualizer</h1>
<p>Rendering is the process of visualizing a scene. In Photon, we use a <a class="elRef" href="../../Engine/html/classph_1_1_visualizer.html">Visualizer</a> to generate a <a class="elRef" href="../../Engine/html/classph_1_1_renderer.html">Renderer</a> to actually render an image. This is where most of the core algorithms meet and work together&ndash;and is arguably the most complex part of a renderer. While there are many types of renderers to choose from, there is hardly an all-purpose renderer as each one of them is designed to deal with different situations. The efficiency of a rendering algorithm is also partly depending on the characteristics of a scene, e.g., sizes of geometries, material properties, etc. At the extreme end, one can always construct a scene that will fail a certain rendering algorithm. Be sure to understand and try different renderers if things do not work out.</p>
<h2><a class="anchor" id="bvpt"></a>
Unidirectional Path Tracing</h2>
<div class="image">
<img src="055_books_based_on_Libri_sulla_mensola_books_by_archemi.jpg" alt=""/>
<div class="caption">
An example image rendered using this renderer.</div></div>
    <p>Though this is a relatively simple renderer to solve the <em>rendering equation</em> as proposed by Kajiya <a class="el" href="citelist.html#CITEREF_Kajiya:1986:Rendering">[4]</a>, this renderer is a good starting point before diving into other solvers. Backward unidirectional path tracing does not handle small light sources well, and scenes with hard-to-find light transport paths are likely to fail, too. This renderer can be constructed by creating a <a class="elRef" href="../../Engine/html/classph_1_1_path_tracing_visualizer.html">PathTracingVisualizer</a> with <a class="elRef" href="../../Engine/html/namespaceph.html#ad2b2972641b7279cac3ed861bfd53962">BVPT</a> energy estimator (use <a class="elRef" href="../../Engine/html/namespaceph.html#ad2b2972641b7279cac3ed861bfd53962">BVPTDL</a> if only direct lighting is required).</p>
<h2><a class="anchor" id="bneept"></a>
Unidirectional Path Tracing with NEE</h2>
<div class="image">
<img src="bathroom_based_on_Salle_de_bain_by_nacimus.jpg" alt=""/>
<div class="caption">
NEE can handle more complex scenes.</div></div>
    <p>With the addition of Next Event Estimation (NEE), unidirectional path tracing can handle common scenes quite effectively. While largely based on the same principle as the non-NEE variant, this renderer combines additional sampling techniques <a class="el" href="citelist.html#CITEREF_Veach:1995:Optimally">[6]</a> to better handle smaller light sources. Similarly, create a <a class="elRef" href="../../Engine/html/classph_1_1_path_tracing_visualizer.html">PathTracingVisualizer</a> with <a class="elRef" href="../../Engine/html/namespaceph.html#ad2b2972641b7279cac3ed861bfd53962">BNEEPT</a> energy estimator to use this renderer.</p>
<h2><a class="anchor" id="vpm"></a>
Vanilla Photon Mapping</h2>
<div class="image">
<img src="vpm_perfumes_by_gp3991.jpg" alt=""/>
<div class="caption">
Perfume bottle and its cap rendered with 500M photons (radius: 0.1, spp: 4). The image has not rendered to convergence to better show the characteristics between different photon mapping techniques.</div></div>
    <p>It is worth to clarify that the project is named <em>Photon</em> not because the focus is on photon mapping techniques, but because photon is the elementary particle that transmit light, and the core of this project is to solve light transport problems. Nevertheless, several photon mapping techniques are available here, and the most fundamental one is vanilla photon mapping <a class="el" href="citelist.html#CITEREF_Jensen:1996:Global">[3]</a>. All photon mapping techniques are capable of <em>merging</em> nearby light transport paths in some way, and this form of path reuse allows them to excel on a wider variety of lighting phenomena. You can get a vanilla photon mapping renderer by creating a <a class="elRef" href="../../Engine/html/classph_1_1_photon_mapping_visualizer.html">PhotonMappingVisualizer</a> in <a class="elRef" href="../../Engine/html/namespaceph.html#acae1a4214e781895f3275c4923f42faa">Vanilla</a> mode.</p>
<h2><a class="anchor" id="ppm"></a>
Progressive Photon Mapping</h2>
<div class="image">
<img src="ppm_perfumes_by_gp3991.jpg" alt=""/>
<div class="caption">
Perfume bottle and its cap rendered with 0.5M photons for 1000 passes (radius: 0.1, spp: 4). The image has not rendered to convergence to better show the characteristics between different photon mapping techniques.</div></div>
    <p>This renderer implements the PPM algorithm by Hachisuka et al. <a class="el" href="citelist.html#CITEREF_Hachisuka:2008:Progressive">[2]</a> The first pass traces a fixed set of view vertices then the following iterative process will estimate the incoming energy on those vertices. The rendered result will be closer to ground truth with more view vertices (and the above image is rendered with maximum view path length = 10). The algorithm can leverage effectively infinite amount of photons to render a scene, achieving superior results then vanilla photon mapping. Create a <a class="elRef" href="../../Engine/html/classph_1_1_photon_mapping_visualizer.html">PhotonMappingVisualizer</a> in <a class="elRef" href="../../Engine/html/namespaceph.html#acae1a4214e781895f3275c4923f42faa">Progressive</a> mode to use this renderer.</p>
<h2><a class="anchor" id="sppm"></a>
Stochastic Progressive Photon Mapping</h2>
<div class="image">
<img src="sppm_perfumes_by_gp3991.jpg" alt=""/>
<div class="caption">
Perfume bottle and its cap rendered with 0.5M photons for 1000 passes (radius: 0.1, spp: 4). The image has not rendered to convergence to better show the characteristics between different photon mapping techniques.</div></div>
    <p>This renderer implements the SPPM algorithm by Hachisuka et al. <a class="el" href="citelist.html#CITEREF_Hachisuka:2009:Stochastic">[1]</a>, and is intended to serve as a reference implementation for other more sophisticated techniques. Tricks and shortcuts are avoided if possible, so the evaluated radiance is more likely to remain correct as the project evolves. Performance is not a major concern for this renderer, so do not use it in situations where time is valuable. Create a <a class="elRef" href="../../Engine/html/classph_1_1_photon_mapping_visualizer.html">PhotonMappingVisualizer</a> in <a class="elRef" href="../../Engine/html/namespaceph.html#acae1a4214e781895f3275c4923f42faa">Progressive</a> mode to use this renderer.</p>
<h2><a class="anchor" id="pppm"></a>
Probabilistic Progressive Photon Mapping</h2>
<div class="image">
<img src="pppm_perfumes_by_gp3991.jpg" alt=""/>
<div class="caption">
Perfume bottle and its cap rendered with 0.5M photons for 1000 passes (radius: 0.1, spp: 4). The image has not rendered to convergence to better show the characteristics between different photon mapping techniques.</div></div>
    <p>This renderer is based on Knaus and Zwicker's paper <a class="el" href="citelist.html#CITEREF_Knaus:2011:Progressive">[5]</a>, which decouples any intermediate radiance estimate from previous iterations. We can treat any photon mapping technique as a black box and parallelizes the calculation of each iteration trivially. However, this renderer consumes more memory in comparison with others. Create a <a class="elRef" href="../../Engine/html/classph_1_1_photon_mapping_visualizer.html">PhotonMappingVisualizer</a> in <a class="elRef" href="../../Engine/html/namespaceph.html#acae1a4214e781895f3275c4923f42faa">Progressive</a> mode to use this renderer.</p>
<h2><a class="anchor" id="autotoc_md19"></a>
Scheduler</h2>
<p>Some <a class="elRef" href="../../Engine/html/classph_1_1_visualizer.html">Visualizer</a>s can make use of a <a class="elRef" href="../../Engine/html/classph_1_1_work_scheduler.html">WorkScheduler</a> to distribute rendering work over multiple processor cores. Different types of schedulers dispatch their work in different ways. When rendering an image, a scheduler will typically use the dimensions of the image and number of iterations to define the total volume of work.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadCenter">Scheduler Type   </th><th class="markdownTableHeadCenter">Dispatch Pattern    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="elRef" href="../../Engine/html/classph_1_1_plate_scheduler.html">Bulk</a>: Layer by layer, each layer convers the whole image.   </td><td class="markdownTableBodyCenter"><img src="bulk_concept.svg" alt="" width="50%" style="pointer-events: none;" class="inline" title="Bulk Scheduler"/>        </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="elRef" href="../../Engine/html/classph_1_1_stripe_scheduler.html">Stripe</a>: Divide image into stripes.   </td><td class="markdownTableBodyCenter"><img src="stripe_concept.svg" alt="" width="50%" style="pointer-events: none;" class="inline" title="Stripe Scheduler"/>        </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="elRef" href="../../Engine/html/classph_1_1_grid_scheduler.html">Grid</a>: Step through evenly divided image row by row.   </td><td class="markdownTableBodyCenter"><img src="grid_concept.svg" alt="" width="50%" style="pointer-events: none;" class="inline" title="Grid Scheduler"/>        </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="elRef" href="../../Engine/html/classph_1_1_tile_scheduler.html">Tile</a>: Step through divided image row by row.   </td><td class="markdownTableBodyCenter"><img src="tile_concept.svg" alt="" width="50%" style="pointer-events: none;" class="inline" title="Tile Scheduler"/>        </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyCenter"><a class="elRef" href="../../Engine/html/classph_1_1_spiral_scheduler.html">Spiral</a>: Step through the image cell by cell in a spiral shape.   </td><td class="markdownTableBodyCenter"><img src="spiral_concept.svg" alt="" width="50%" style="pointer-events: none;" class="inline" title="Spiral Scheduler"/>        </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyCenter"><a class="elRef" href="../../Engine/html/classph_1_1_spiral_grid_scheduler.html">SpiralGrid</a>: Similar to spiral scheduler, except that each cell is subdivided into smaller cells.   </td><td class="markdownTableBodyCenter"><img src="spiral_grid_concept.svg" alt="" width="50%" style="pointer-events: none;" class="inline" title="Spiral Grid Scheduler"/>       </td></tr>
</table>
<h1><a class="anchor" id="observer"></a>
Observer</h1>
<p><a class="elRef" href="../../Engine/html/classph_1_1_observer.html">Observer</a> plays an important role in a scene: it captures incoming energy and record it on its sensing device called <a class="elRef" href="../../Engine/html/classph_1_1_film.html">Film</a>&ndash;so you can observe the virtual world which just got rendered. Observers can generate energy <a class="elRef" href="../../Engine/html/classph_1_1_receiver.html">Receiver</a> and a common example of it is camera, which senses and records lighting as a photograph.</p>
<h2><a class="anchor" id="pinhole"></a>
Pinhole Camera</h2>
<div class="image">
<img src="pinhole_camera_teaser.jpg" alt=""/>
<div class="caption">
Image rendered by a pinhole camera. Notice the sharpness in foreground and background; there is no difference and it appears to be in focus everywhere.</div></div>
    <p>Photon currently supports two types of perspective camera: <a class="elRef" href="../../Engine/html/classph_1_1_pinhole_camera.html">PinholeCamera</a> and <a class="elRef" href="../../Engine/html/classph_1_1_thin_lens_camera.html">ThinLensCamera</a>. A pinhole camera is simply composed of a hole (which serves as its lens system) and a film. Images captured by this camera is similar to how a normal human perceives the world but with several simplifications. Due to its simplicity, it is widely adopted in computer graphics industry. This kind of camera can be generated by creating a <a class="elRef" href="../../Engine/html/classph_1_1_single_lens_observer.html">SingleLensObserver</a> with a zero lens radius.</p>
<h2><a class="anchor" id="thinlens"></a>
Thin Lens Camera</h2>
<div class="image">
<img src="thinlens_camera_teaser.jpg" alt=""/>
<div class="caption">
Image rendered by a thin-lens camera. Notice the depth of field effect.</div></div>
    <p>For thin lens camera, as its name suggests, the lens system in this camera is assumed to be a single lens with negligible thickness. The biggest advantage of it is that depth of field effects are possible under this model. In the following render, depth of field is achieved by a 72 mm lens focusing on the first metallic monkey. This camera can be created similarly as <a class="el" href="#thinlens">pinhole camera</a> by using a non-zero lens radius.</p>
<h2><a class="anchor" id="autotoc_md20"></a>
Environment Camera</h2>
<h2><a class="anchor" id="autotoc_md21"></a>
Energy Measurement</h2>
<h1><a class="anchor" id="autotoc_md22"></a>
Image</h1>
<h2><a class="anchor" id="autotoc_md23"></a>
Texture</h2>
<h2><a class="anchor" id="autotoc_md24"></a>
Film</h2>
<h2><a class="anchor" id="autotoc_md25"></a>
Filtering</h2>
<h2><a class="anchor" id="autotoc_md26"></a>
Tone-mapping</h2>
<h2><a class="anchor" id="autotoc_md27"></a>
Reading and Writing</h2>
<h2><a class="anchor" id="autotoc_md28"></a>
Merging</h2>
<h1><a class="anchor" id="autotoc_md29"></a>
Material</h1>
<h2><a class="anchor" id="autotoc_md30"></a>
Surface Behavior</h2>
<h2><a class="anchor" id="autotoc_md31"></a>
Volume Behavior</h2>
<h1><a class="anchor" id="autotoc_md32"></a>
Geometry</h1>
<p>If there is a ball in the scene, we can create a <a class="elRef" href="../../Engine/html/classph_1_1_g_sphere.html">sphere geometry</a> to represent it; if there is a piece of paper on the table, we can use a <a class="elRef" href="../../Engine/html/classph_1_1_g_rectangle.html">rectangle geometry</a> to model it. Geometries are the bare bones of a scene: materials, lights, physical motionsâ€¦ are all built on top of geometries. We show some common types of geometries in the following sections to give you a rough idea of how geometries are like in Photon renderer.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Intersectable and Primitive</h2>
<p>When a <a class="elRef" href="../../Engine/html/classph_1_1_geometry.html">Geometry</a> is defined in the scene, it will be converted to an <a class="elRef" href="../../Engine/html/classph_1_1_intersectable.html">Intersectable</a> before actual rendering begins. The renderer further treat some intersectable types as <a class="elRef" href="../../Engine/html/classph_1_1_primitive.html">Primitive</a> from which a richer set of functionalities are expected. In a similar way, some intersectable types are being classified as <a class="elRef" href="../../Engine/html/classph_1_1_intersector.html">Intersector</a> and they typically act as an aggregate of intersectables.</p>
<dl class="section note"><dt>Note</dt><dd>These distinctions are not that important from a users perspective. However, for developers or researchers that want to dive into the source it is best to keep these in mind.</dd></dl>
<h2><a class="anchor" id="autotoc_md34"></a>
Basic Shapes</h2>
<p>These are common shapes to have in a renderer and you are likely to find them also on other renderers. They are also useful for defining the shape of light sources or for further tessellation. We start by introducing rectangle shape, which can be created by <a class="elRef" href="../../Engine/html/classph_1_1_g_rectangle.html">rectangle geometry</a>.</p>
<div class="image">
<img src="rectangle.jpg" alt=""/>
<div class="caption">
Rectangle lies on the XY-plane by default. With UV in [0, 1] across the whole surface.</div></div>
    <p>We also have freestanding triangle shape which can be created by <a class="elRef" href="../../Engine/html/classph_1_1_g_triangle.html">triangle geometry</a>.</p>
<div class="image">
<img src="triangle.jpg" alt=""/>
<div class="caption">
Triangle has customizable UVs and normals.</div></div>
    <dl class="section note"><dt>Note</dt><dd>It is not recommended to build complex shapes out of multiple freestanding triangle geometries unless you have good reasons to do so. It is highly memory inefficient.</dd></dl>
<p>There is also sphere shape created by <a class="elRef" href="../../Engine/html/classph_1_1_g_sphere.html">sphere geometry</a>. The sphere generated is a true sphere by default (not a triangle mesh counterpart).</p>
<div class="image">
<img src="sphere.jpg" alt=""/>
<div class="caption">
An example sphere shape.</div></div>
    <p>You can also build a cube or box shape using <a class="elRef" href="../../Engine/html/classph_1_1_g_cuboid.html">cuboid geometry</a>. It is quite useful to have a generalized cube at hand. Unlike cubes, a cuboid allows variable extents. Cuboids are axis-aligned bounding boxes (AABB) in their local space.</p>
<div class="image">
<img src="cuboid.jpg" alt=""/>
<div class="caption">
A Cuboid (in fact a cube in this image).</div></div>
    <p>A bonus to have cuboids is that voxel games like <a href="https://en.wikipedia.org/wiki/Minecraft">Minecraft</a> can be rendered easily. Here is a work-in-progress render of a Minecraft level parser that tries to translate in-game data into PSDL:</p>
<div class="image">
<img src="textured_mc.jpg" alt=""/>
<div class="caption">
Test render of a Minecraft level parser.</div></div>
    <p>Almost all shapes are built from triangle meshes for a typical scene. Games, modeling programs, and other applications typically use triangle mesh to represent arbitrary 3-D shapes. It is basically a collection of triangles grouping in a way that approximate some shapes. It can be created by <a class="elRef" href="../../Engine/html/classph_1_1_g_triangle_mesh.html">triangle mesh geometry</a> or <a class="elRef" href="../../Engine/html/classph_1_1_g_ply_polygon_mesh.html">polygon mesh</a>. The later is a more memory efficient representation of a triangle mesh and supports customizable vertex layout and arbitrary index bit precision. Binary storage format is also supported (<a href="https://en.wikipedia.org/wiki/PLY_(file_format)">PLY format</a>).</p>
<div class="image">
<img src="triangle_mesh.jpg" alt=""/>
<div class="caption">
Stanford bunny built from a triangle mesh.</div></div>
    <h2><a class="anchor" id="autotoc_md35"></a>
Advanced Shapes</h2>
<p>We also support some interesting shapes such as wave and fractals. These special geometries are sometimes useful for modeling a scene. One of them is the <a href="https://en.wikipedia.org/wiki/Menger_sponge">Menger sponge</a>, a famous fractal shape. It can be created by <a class="elRef" href="../../Engine/html/classph_1_1_g_menger_sponge.html">Menger sponge geometry</a>.</p>
<div class="image">
<img src="menger_sponge.jpg" alt=""/>
<div class="caption">
A fractal geometry (Menger sponge).</div></div>
    <p>A wave shape is basically a cuboid with its top surface being tessellated according to a superposition of 2-D sine and cosine functions. It can be created by <a class="elRef" href="../../Engine/html/classph_1_1_g_wave.html">wave geometry</a>.</p>
<div class="image">
<img src="045_water_dragon_color_light.jpg" alt=""/>
<div class="caption">
A triangle mesh submerged inside a wave geometry.</div></div>
    <h2><a class="anchor" id="autotoc_md36"></a>
Acceleration Structure</h2>
<h1><a class="anchor" id="autotoc_md37"></a>
Light</h1>
<h2><a class="anchor" id="autotoc_md38"></a>
Emitter</h2>
<h1><a class="anchor" id="autotoc_md39"></a>
Sample Source</h1>
<h2><a class="anchor" id="autotoc_md40"></a>
Sample Generator</h2>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.11.0 </li>
  </ul>
</div>
</body>
</html>
